/* ------------------------------------------------------------------ */
/* CDPLAY.CMD - simple text mode CD player                            */
/*                                                                    */
/* (c) Copyright Bernd Schemmer 2000                                  */
/*                                                                    */
/*-Author:                                                            */
/*   Bernd Schemmer                                                   */
/*   Stalburgstr. 14                                                  */
/*   D-60318 Frankfurt am Main                                        */
/*   Germany                                                          */
/*   Bernd.Schemmer@gmx.de                                            */
/*                                                                    */
/*-History:                                                           */
/*   30.01.2000 /bs v1.00                                             */
/*     - initial release                                              */
/*                                                                    */
/*                                                                    */
/*                                                                    */
/*-Distribution:                                                      */
/*   This code may be distributed freely and used in other programs.  */
/*   Please give credit where credit is due.                          */
/*   If you need further help, feel free to contact me at the address */
/*   noted above.                                                     */
/*                                                                    */
/*-Description:                                                       */
/*   CDPLAY.CMD is a very simple CD play program using the REXX       */
/*   extension for multimedia.                                        */
/*                                                                    */
/*-Usage:                                                             */
/*   CDPLAY   {/L:logfile} {/H} {/Silent} {/NoSound} {/NoAnsi}        */
/*            {/Trace}                                                */
/*                                                                    */
/*-where:                                                             */
/*                                                                    */
/*   /L:logFile - logfile is the name of the logfile :-)              */
/*                This parameter is case-sensitive!                   */
/*                Note: use /L:"logfile" if the name of the logfile   */
/*                      contains blanks or special chars              */
/*                def.: do not use a logfile                          */
/*                                                                    */
/*   /H         - show usage, you may also use                        */
/*                /h, /?, /HELP, -h, -H, -HELP or -?                  */
/*                (MAIN is not called!)                               */
/*                                                                    */
/*   /Silent    - suppress all messages (except error messages)       */
/*                You should also use the parameter /L:logfile if you */
/*                use this parameter!                                 */
/*                You may also set the environment variable SILENT to */
/*                "1" to suppress all messages.                       */
/*                                                                    */
/*   /NoSound   - suppress all sounds. You may also set the           */
/*                environment variable SOUND to "0" to suppress the   */
/*                sounds.                                             */
/*                                                                    */
/*   /NoAnsi    - do not use ANSI codes. You may also set the         */
/*                environment variable ANSI to "0" to suppress the    */
/*                use of ANSI codes.                                  */
/*                                                                    */
/*   /Trace     - turn TRACE on before calling MAIN. You may also     */
/*                set the environment variable RXTTRACE to ON to      */
/*                turn the TRACE mode for MAIN on.                    */
/*                                                                    */
/* NOTE:                                                              */
/*   You must use at least one blank to separate the parameter.       */
/*                                                                    */
/*                                                                    */
/*-returncodes:                                                       */
/*      0 - execution okay                                            */
/*    240 ... 252                                                     */
/*          reserved for the runtime system                           */
/*    253 - syntax help called (parameter /h)                         */
/*    254 - user break (CTRL-C)                                       */
/*    255 - internal runtime system error                             */
/*   else - program specific errors                                   */
/*                                                                    */
/*-Notes:                                                             */
/*                                                                    */
/*                                                                    */
/* Based on TEMPLATE.CMD v3.07, TEMPLATE is (c) 1997 Bernd Schemmer,  */
/* Stalburgstr. 14, 60318 Frankfurt, Germany, Bernd.Schemmer@gmx.de   */
/*                                                                    */
/* Read the documentation for my REXX template TEMPLATE.CMD           */
/* carefully before changing this program!                            */
/* ------------------------------------------------------------------ */

  call trace 'off'      /* turn interactive trace off                 */
                        /* use this statement as the first statement  */
                        /* in your program, to ignore the value of    */
                        /* the environment variable RXTRACE.          */

                  global. = ''  /* init the stem global. with ''      */

/*** change the following values to your need                       ***/

                        /* additional parameter                 v3.06 */
                        /* (string for the usage routine)       v3.06 */
  global.__userUsage  = ''                                   /* v3.06 */

         global.__Version = 1.0          /* Version of YOUR program   */

       global.__SignOnMsg = 1   /* set to 0 if you do not want the    */
                                /* program start and end messages     */

         global.__NeedCID = 0   /* set to 1 if you need CID support   */

      global.__NeedColors = 1   /* set to 1 if you want colored msgs  */

  global.__NeedPatchCheck = 1   /* set to 1 if you want the program   */
                                /* to search for a patched version of */
                                /* this program                       */

              /* set default values for EXPOSELIST if necessary       */
  exposeList = 'msgStem.'


                    /* base message number                            */
  Global.__BaseMsgNo = 1000

              /* name of the routine for the message handling         */
              /* Note: Use '' for hardcoded messages                  */
  global.__GetMsg = ''

             /* note: set the variable prog.__STDOUT to "STDERR:"     */
             /*       or "NUL" if your program is a filter program!   */

  prog.__STDOUT = 'STDOUT'        /* necessary for Object REXX        */
  prog.__STDERR = 'STDOUT'        /* necessary for Object REXX        */
                                                                   /*!*/
/***                End of variables to change                      ***/
/*      HINT: The further program code is in the function MAIN        */

/***        End of Part 1 of the source code of TEMPLATE.CMD        ***/

/***       Start of Part 2 of the source code of TEMPLATE.CMD       ***/

/*************** DO NOT CHANGE THE FOLLOWING LINES ********************/

                        /* names of the global variables, which all   */
                        /* procedures must know                       */
  exposeList = 'prog. screen. I!. global. exposeList ' exposeList

                        /* check the type of the base message number  */
  if datatype( global.__BaseMsgNo, 'W' ) <> 1 then
    global.__BaseMsgNo = 1000

                        /* init internal variables                    */
  I!. = ''
                        /* save default STDOUT and STDERR             */
  if symbol( 'prog.__STDOUT' ) = 'VAR' then
    I!.__2 = prog.__STDOUT
  if symbol( 'prog.__STDERR' ) = 'VAR' then
    I!.__3 = prog.__STDERR

                        /* init the stems prog. & screen.             */
  parse value '' with prog. screen.

                        /* reset the timer                            */
  call time 'R'

                        /* restore default STDOUT and STDERR          */
  prog.__STDOUT = I!.__2;    prog.__STDERR = I!.__3

                        /* get the number of the first line with      */
                        /* user code                                  */
  call I!.__GetUserCode

/* ------------------------------------------------------------------ */
/* install the error handler                                          */

                        /* break errors (CTRL-C)                      */
  CALL ON HALT        NAME I!.__UserAbort
                        /* syntax errors                              */
  SIGNAL ON SYNTAX    NAME I!.__ErrorAbort
                        /* using of not initialisized variables       */
  SIGNAL ON NOVALUE   NAME I!.__ErrorAbort
                        /* failure condition                          */
  SIGNAL ON FAILURE   NAME I!.__ErrorAbort
                        /* error condition                            */
  SIGNAL ON ERROR     NAME I!.__ErrorAbort
                        /* disk not ready condition                   */
  SIGNAL ON NOTREADY  NAME I!.__ErrorAbort

/* ------------------------------------------------------------------ */
/* init the variables                                                 */

                        /* get & save the parameter                   */
  parse arg I!.__RealParam 1 prog.__Param

                        /* init the variables                         */

                        /* define exit code values                    */
  global.__ErrorExitCode = 255
     global.__OKExitCode = 0

                        /* init the compound variable prog.           */
  call I!.__InitProgStem

                        /* define the variables for CID programs      */
  call I!.__InitCIDVars

                        /* init the program exit code                 */
  prog.__ExitCode = global.__OKExitCode

                        /* check the parameter and env. variables     */
                        /* This must run before I!.__InitColorVars!   */
  call I!.__chkPandE

                        /* define the color variables                 */
  call I!.__InitColorVars

                        /* check if there is a logfile parameter      */
  call I!.__SetLogVars

/* ------------------------------------------------------------------ */
/* show program start message                                         */

  call I!.__SignMsg

/* ------------------------------------------------------------------ */
/* check if there is a patched version of this program                */

  call I!.__CheckPatch

/* ------------------------------------------------------------------ */

                        /* check for a help parameter                 */
  if pos( translate( word( prog.__Param,1 ) ), ,
          '/?/H/HELP-?-H-HELP' ) <> 0 then
  do
    prog.__exitCode = 253

    call I!.__CallUserProc 1, 'ShowUsage'

    SIGNAL I!.__programEnd

  end /* pos( translate( ... */

/* ------------------------------------------------------------------ */

                        /* call the main procedure                    */
  call I!.__CallUserProc 2, 'main' strip( prog.__Param )

                        /* use the return code of 'main' as exitcode  */
                        /* if a returncode was returned               */
  if symbol( 'I!.__UserProcRC' ) == 'VAR' then
    prog.__ExitCode = I!.__UserProcRC

/* ------------------------------------------------------------------ */
/* house keeping                                                      */

I!.__ProgramEnd:

                                /* call the exit routines             */
  do while prog.__exitRoutines <> ''

                        /* delete the name of the routine from the    */
                        /* list to avoid endless loops!               */
    parse var prog.__ExitRoutines I!.__cer prog.__ExitRoutines

    call I!.__CallUserProc 1, I!.__cer

  end /* do while prog.__ExitRoutines <> '' */

                                /* restore the current directory      */
  if symbol( 'prog.__CurDir' ) == 'VAR' then
    call directory prog.__CurDir

                                /* show sign off message              */
  call I!.__SignMsg 'E'

EXIT prog.__ExitCode

/* ------------------------------------------------------------------ */
/*-function: show the sign on or sign off message                     */
/*                                                                    */
/*-call:     I!.__SignMsg which                                       */
/*                                                                    */
/*-where:    which - 'E' - show the sign off message                  */
/*                         else show the sign on message              */
/*                                                                    */
/*-returns:  nothing                                                  */
/*                                                                    */
I!.__SignMsg: PROCEDURE expose (exposeList)
  if global.__SignOnMsg <> 1 then
    RETURN

                        /* default: program start message             */
  i = 12

  if arg(1) = 'E' then
  do
    i = 13
                        /* program end message                        */
    i!.__rc1 = prog.__ExitCode

                                /* check if the exit code is decimal  */
                                /* and convert it to hexadecimal if   */
                                /* possible                           */
    if dataType( prog.__ExitCode, 'W' ) then
    do
      if prog.__ExitCode < 0 then
        prog.__ExitCode = 65536 + prog.__ExitCode
      i!.__rc2 = D2X( prog.__ExitCode )
    end /* if .. */

  end /* if arg(1) = 'E' then */

  screen.__CurColor = screen.__SignOnColor
  call Log I!.__GetMsg( i, prog.__Name, global.__Version, date(),,
                        time(), i!.__rc1, i!.__rc2 )
  screen.__CurColor = screen.__NormalColor
RETURN

/* ------------------------------------------------------------------ */
/*-function: call a user defined routine                              */
/*           (avoid errors if the routine is not defined)             */
/*                                                                    */
/*-call:     I!.__CallUserProc errorAction, procName {procParameter}  */
/*                                                                    */
/*-where:    errorAction - action, if procName is not defined         */
/*                         0: do nothing (only set the RC)            */
/*                         1: show a warning and set the RC           */
/*                         2: abort the program                       */
/*           procName - name of the procedure                         */
/*           procParameter - parameter for the procedure              */
/*                                                                    */
/*-returns:  1 - ok                                                   */
/*           0 - procname not found                                   */
/*                                                                    */
/*-output:   I!.__UserProcRC - Returncode of the called procedure     */
/*                             (dropped if the proedure don't         */
/*                             return a value)                        */
/*                                                                    */
I!.__CallUserProc: PROCEDURE expose (exposeList) result rc sigl
  parse arg I!.__ErrorAction , I!.__ProcN I!.__ProcP

  I!.__thisRC = 0
  drop I!.__UserProcRC

  iLine = 'call ' I!.__ProcN
  if prog.__Trace = 1 & I!.__ProcN = 'main' then
    iLine = 'trace ?a;'|| iLine

/** DO NOT CHANGE, ADD OR DELETE ONE OF THE FOLLOWING SEVEN LINES!!! **/
  I!.__ICmdLine = GetLineNo()+2+(I!.__ProcP <> '')*2               /*!*/
  if I!.__ProcP = '' then                                          /*!*/
    interpret iLine                                                /*!*/
  else                                                             /*!*/
    interpret iLine "I!.__ProcP"                                   /*!*/
/** DO NOT CHANGE, ADD OR DELETE ONE OF THE PRECEEDING SEVEN LINES!! **/

/* Caution: The CALL statement changes the variable RESULT!           */
  I!.__0 = trace( 'off' )

  I!.__thisRC = 1
  if symbol( 'RESULT' ) == 'VAR' then
    I!.__UserProcRC = value( 'RESULT' )
    
                    /* this label is used if the interpret command    */
                    /* ends with an error                             */
I!.__CallUserProc2:

  if I!.__ThisRC = 0 then
  do
    if I!.__ErrorAction = 2 then
      call ShowError global.__ErrorExitCode , ,
                   I!.__GetMsg( 1, I!.__ProcN )

    if I!.__ErrorAction = 1 then
      call ShowWarning I!.__GetMsg( 1 , I!.__ProcN )
  end /* if I!.__thisRC = 0 then */

RETURN I!.__thisRC

/* ------------------------------------------------------------------ */
/*-function: set the variables for the logfile handling               */
/*                                                                    */
/*-call:     I!.__SetLogVars                                          */
/*                                                                    */
/*-input:    prog.__Param - parameter for the program                 */
/*                                                                    */
/*-output:   prog.__LogFile     - name of the logfile (or NUL)        */
/*           prog.__LogSTDERR   - string to direct STDERR into the    */
/*                                logfile                             */
/*           prog.__LogSTDOUT   - string to direct STDOUT into the    */
/*                                logfile                             */
/*           prog.__LogAll      - string to direct STDOUT and STDERR  */
/*                                into the logfile                    */
/*           prog.__LogFileParm - string to inherit the logfile       */
/*                                parameter to a child CMD            */
/*           prog.__Param       - program parameter without the       */
/*                                logfile parameter                   */
/*                                                                    */
/*-returns:  nothing                                                  */
/*                                                                    */
I!.__SetLogVars: PROCEDURE expose (exposeList)

  parse var prog.__Param prog.__param '/L:' logFileName ' ' rest
  if left( logFileName,1 ) = '"' then                        /* v3.07 */
    parse value logFileName rest with '"' logFilename '"' rest

  prog.__param = prog.__Param rest

                        /* avoid an error if the drive is not ready   */
  SIGNAL OFF NOTREADY

                        /* default log device is the NUL device       */
  prog.__LogFile = 'NUL'

  if logFileName <> '' then
  do
                        /* check if we can write to the logfile       */
    logStatus = stream( logFileName, 'c', 'OPEN WRITE')
    if logStatus <> 'READY:' then
    do
      prog.__LogFileParm = ''

      call ShowWarning I!.__GetMsg( 2, logFileName, logStatus )

    end /* if logStatus <> 'READY:' then */
    else
    do
                        /* close the logfile                          */
      call stream logFileName, 'c', 'CLOSE'

                        /* get the fully qualified name of the        */
                        /* logfile                                    */
                        /*                                      v3.04 */
      parse upper value stream( logFileName, 'c', 'QUERY EXIST' ) WITH prog.__LogFile
    
      prog.__LogFileParm = '/L:"' || prog.__LogFile || '"'

    end /* else */
  end /* if prog.__LogFile <> '' then */

  fn = ConvertNameToOS( prog.__LogFile )

                        /* variable to direct STDOUT of an OS/2       */
                        /* program into the logfile                   */
  prog.__LogSTDOUT = ' 1>>' || fn

                        /* variable to direct STDERR of an OS/2       */
                        /* program into the logfile                   */
  prog.__LogSTDERR = ' 2>>' || fn 

                        /* variable to direct STDOUT and STDERR of    */
                        /* an OS/2 program into the log file          */
  prog.__LogALL = prog.__LogSTDERR '1>>&2'

RETURN

/* ------------------------------------------------------------------ */
/*-function: check the parameter and the environment variables for    */
/*           the runtime system                                       */
/*                                                                    */
/*-call:     I!.__chkPandE                                            */
/*                                                                    */
/*-input:    prog.__Param - parameter for the program                 */
/*           prog.__env - name of the environment                     */
/*                                                                    */
/*-output:   prog.__QuietMode - 1 if parameter '/Silent' found        */
/*                              or environment variable SILENT set    */
/*           prog.__NoSound   - 1 if parameter '/NoSound' found       */
/*                              or environment variable SOUND set     */
/*           screen.          - "" if parameter '/NoANSI' found       */
/*                              or environment variable ANSI set      */
/*           prog.__Param     - remaining parameter for the procedure */
/*                              MAIN.                                 */
/*           prog.__Trace     - 1 if parameter '/Trace' found         */
/*                              or if the environment variable        */
/*                              RXTTRACE is set to MAIN               */
/*                                                                    */
/*-returns:  nothing                                                  */
/*                                                                    */
I!.__chkPandE: PROCEDURE expose (exposeList)

  global.__verbose = value( 'VERBOSE' ,, prog.__env )

  o!.0 = 4                              /* no. of known parameters    */
                                        /* and environment variables  */

  o!.1.parm = '/SILENT'                 /* parameter name             */
  o!.1.env  = 'SILENT'                  /* name of the env. var       */
  o!.1.vals = 'ON 1'                    /* possible values for the    */
                                        /* environment variable       */
  o!.1.stmt = 'prog.__QuietMode=1'      /* statement to execute       */
                                        /* if this parameter was      */
                                        /* entered or the environment */
                                        /* variable is set            */

  o!.2.parm = '/NOSOUND'                /* turn sound off             */
  o!.2.env  = 'SOUND'
  o!.2.vals = 'OFF 0'
  o!.2.stmt = 'prog.__NoSound=1'

  o!.3.parm = '/NOANSI'                 /* turn ANSI support off      */
  o!.3.env  = 'ANSI'
  o!.3.vals = 'OFF 0'
  o!.3.stmt = 'global.__NeedColors=0'

  o!.4.parm = '/TRACE'          /* exeucte MAIN in single step mode   */
  o!.4.env  = 'RXTTRACE'
  o!.4.vals = 'MAIN'
  o!.4.stmt = 'prog.__Trace=1'

  do i = 1 to o!.0
                        /* check the parameter                        */
    j = wordPos( o!.i.parm, translate( prog.__Param ) )
    if j = 0 then       /* no parameter found, check the env. var     */
      j = wordPos( translate( value( o!.i.env ,, prog.__env ) ) ,,
                    o!.i.vals )
    else                /* parameter found, delete the parameter      */
      prog.__Param = strip( delWord( prog.__Param, j,1 ) )

                        /* if j is not zero either the parameter was  */
                        /* found or the environment variable is set   */
    if j <> 0 then
      interpret o!.i.stmt
  end /* do i = 1 to o!.0 */

RETURN

/* ------------------------------------------------------------------ */
/*-function:  convert a file or directory name to OS conventions      */
/*            by adding a leading and trailing double quote           */
/*                                                                    */
/*-call:      convertNameToOS dir_or_file_name                        */
/*                                                                    */
/*-where:     dir_or_file_name = name to convert                      */
/*                                                                    */
/*-returns:   converted file or directory name                        */
/*                                                                    */
ConvertNameToOS: PROCEDURE expose (exposeList)
  parse arg fn

  if left( fn,1 ) = '-' then                                 /* v3.07 */
    fn = '.\' || fn                                          /* v3.07 */

RETURN '"' || fn || '"'                                      /* v3.06 */

/* ------------------------------------------------------------------ */
/*-function: flush the default REXX queue                             */
/*                                                                    */
/*-call:     FlushQueue                                               */
/*                                                                    */
/*-returns:  ''                                                       */
/*                                                                    */
FlushQueue: /* PROCEDURE expose (exposeList) */
  do while QUEUED() <> 0
    parse pull
  end /* do while QUEUED() <> 0 */
RETURN ' '                                                   /* v3.03 */

/* ------------------------------------------------------------------ */
/*-function: include a file if it exists                              */
/*                                                                    */
/*-call:     TryInclude( IncludeFile )                                */
/*                                                                    */
/*-where:    IncludeFile = name of the file to include                */
/*                                                                    */
/*-output:   prog.__rc = 0 - include file executed                    */
/*           else: file not found                                     */
/*                                                                    */
/*-returns:  ''                                                       */
/*                                                                    */
TryInclude:
  parse upper arg I!.__IncFileName
  prog.__rc = 1

  if I!.__IncFileName = '' then
    RETURN ' '                                               /* v3.03 */

  if stream( I!.__IncFileName,'c','QUERY EXIST' ) = '' then
    RETURN ' '                                               /* v3.03 */

  prog.__rc = 0

  /* execute INCLUDE */

/* ------------------------------------------------------------------ */
/*-function: include a file                                           */
/*                                                                    */
/*-call:     Include( IncludeFile )                                   */
/*                                                                    */
/*-where:    IncludeFile = name of the file to include                */
/*                                                                    */
/*-returns:  ''                                                       */
/*                                                                    */
Include:
  parse upper arg I!.__IncFileName

                        /* check if the include file exists           */
  if stream( I!.__IncFileName, 'c', 'QUERY EXIST' ) == '' then
    call ShowError global.__ErrorExitCode, ,
                   I!.__GetMsg( 3, I!.__IncFileName )

                        /* read and interpret the include file        */
  do I!.__IncLineNO = 1 while lines( I!.__IncFileName ) <> 0
    I!.__IncCurLine = ''
                        /* save the absolute position of the start of */
                        /* this line for the error handler            */
    I!.__IncCurLinePos = stream(I!.__IncFileName,'c','SEEK +0')

                        /* handle multi line statements               */
    do forever
      I!.__IncCurLine = I!.__IncCurLine ,
                        strip( lineIn( I!.__IncFileName ) )

      if right( I!.__IncCurLine,1 ) <> ',' then
        leave

                        /* statement continues on the next line       */
      if lines( I!.__IncFileName ) == 0 then
        call ShowError global.__ErrorExitCode ,,
             I!.__GetMsg( 4, I!.__IncFileName )

                        /* the next lines is only executed if the IF */
                        /* statement above is FALSE                  */
      I!.__IncCurLine = substr( I!.__IncCurLine,1, ,
                                length( I!.__IncCurLine )-1 )

    end /* do forever */

    I!.__IncActive = 1
    interpret I!.__IncCurLine
    I!.__IncActive = 0

  end /* do I!.__IncLineNO = 1 while lines( I!.__IncFileName ) <> 0 ) */

                        /* close the include file!                    */
  call stream I!.__IncFileName, 'c', 'CLOSE'

                    /* do NOT return a NULL string ('')!        v3.03 */
                    /* Due to a bug in the CMD.EXE this will    v3.03 */
                    /* cause the error SYS0008 after the 32nd   v3.03 */
                    /* call of this function!                   v3.03 */
RETURN ' '

/* ------------------------------------------------------------------ */
/*-function: init color variables                                     */
/*                                                                    */
/*-call:     I!.__InitColorVars                                       */
/*                                                                    */
/*-returns:  nothing                                                  */
/*                                                                    */
I!.__InitColorVars: /* PROCEDURE expose (exposeList) */

  if 1 == global.__NeedColors then
  do
    escC = '1B'x || '['                                      /* v3.04 */

    t1 = 'SAVEPOS RESTPOS ATTROFF' ,                         /* v3.05 */
         'HIGHLIGHT NORMAL BLINK INVERS INVISIBLE'           /* v3.05 */

    t2 = 's u 0;m 1;m 2;m 5;m 7;m 8;m'                       /* v3.05 */

    screen.__DELEOL = escC || 'K'                            /* v3.05 */

    do i = 1 to 8                                            /* v3.05 */

      call value 'SCREEN.__' || word( t1, i ) ,,             /* v3.05 */
                 escC || word( t2,i )                        /* v3.05 */

                                                             /* v3.05 */
      s = word( 'BLACK RED GREEN YELLOW BLUE MAGNENTA CYAN WHITE', i )
      call value 'SCREEN.__FG' || s,,                        /* v3.05 */
                 escC || 29+i || ';m'                        /* v3.05 */
      call value 'SCREEN.__BG' || s,,                        /* v3.05 */
                 escC || 39+i || ';m'                        /* v3.05 */
    end /* do i = 1 to 8 */                                  /* v3.05 */

    drop t1 t2 s i                                           /* v3.05 */

/* --------------------------- */
                        /* define color variables                     */
    screen.__ErrorColor  = screen.__AttrOff || screen.__Highlight || ,
                           screen.__FGYellow || screen.__bgRed

    screen.__NormalColor = screen.__AttrOff ||                       ,
                           screen.__fgWhite || screen.__bgBlack

    screen.__DebugColor  = screen.__AttrOff || screen.__Highlight || ,
                           screen.__fgBlue || screen.__bgWhite

    screen.__PromptColor = screen.__AttrOff || screen.__Highlight || ,
                           screen.__fgYellow || screen.__bgMagnenta

/* +++++++++++++++ DO NOT USE THE FOLLOWING COLORS! +++++++++++++++++ */
    screen.__SignOnColor = screen.__AttrOff || screen.__Highlight || ,
                           screen.__fggreen || screen.__bgBlack

    screen.__PatchColor  = screen.__AttrOff || screen.__Highlight || ,
                           screen.__fgcyan || screen.__bgRed
/* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */

                            /* set the default color                  */
    screen.__CurColor    = screen.__NormalColor

                            /* turn ANSI word wrapping on             */
    if prog.__QuietMode <> 1 then
      call CharOut prog.__STDOUT, '1B'x || '[7h'

  end /* if 1 == global.__NeedColors then */

RETURN

/* ------------------------------------------------------------------ */
/*-function: init the stem prog.                                      */
/*                                                                    */
/*-call:     I!.__InitProgStem                                        */
/*                                                                    */
/*-returns:  nothing                                                  */
/*                                                                    */
/*-Note:     DO NOT ADD ANY CODE TO THIS ROUTINE!                     */
/*                                                                    */
I!.__InitProgStem: /* PROCEDURE expose (exposeList) */
  prog.__Defparms = ' {/L:logfile} {/H} {/Silent} {/NoAnsi} {/NoSound} {/Trace}'

                        /* get drive, path and name of this program   */
  parse upper source . . prog.__FullName
        prog.__Drive = filespec( 'D', prog.__FullName )
         prog.__Path = filespec( 'P',  prog.__FullName )
         prog.__Name = filespec( 'N',  prog.__FullName )
      prog.__progDir = prog.__Drive || prog.__Path           /* v3.08 */

                                                             /* v3.05 */
 parse upper value 'V3.08 1 80 25 OS2ENVIRONMENT' directory() with ,
             prog.__Version ,         /* version of template    v3.05 */
             prog.__UserAbort ,       /* allow useraborts       v3.05 */
             prog.__ScreenCols ,      /* def. screen cols       v3.05 */
             prog.__ScreenRows ,      /* def. screen rows       v3.05 */
             prog.__env ,             /* def. environment       v3.05 */
             prog.__CurDir            /* current directory      v3.05 */

                                /* install a local error handler      */
  SIGNAL ON SYNTAX Name I!.__InitProgStem1
                                /* try to call SysTextScreenSize()    */
  parse value SysTextScreenSize() with prog.__ScreenRows prog.__ScreenCols

I!.__InitProgStem1:

RETURN

/* ------------------------------------------------------------------ */
/*-function: init the variables for CID programs (only if the value   */
/*           of the variable global.__NeedCID is 1)                   */
/*                                                                    */
/*-call:     I!.__InitCIDVars                                         */
/*                                                                    */
/*-returns:  nothing                                                  */
/*                                                                    */
/*-Note:     DO NOT ADD ANY CODE TO THIS ROUTINE!                     */
/*           Returncodes as defined by LCU 2.0                        */
/*                                                                    */
I!.__InitCIDVars: /* PROCEDURE expose (exposeList) exposeList CIDRC. */

  if 1 == global.__NeedCID then
  do

    I!.__cidRCValues = ,                                     /* v3.05 */
      '0000'x 'SUCCESSFUL_PROGRAM_TERMINATION',              /* v3.05 */
      '0004'x 'SUCCESSFUL_LOG_WARNING_MESSAGE',              /* v3.05 */
      '0008'x 'SUCCESSFUL_LOG_ERROR_MESSAGE',                /* v3.05 */
      '0012'x 'SUCCESSFUL_LOG_SEVERE_ERROR',                 /* v3.05 */
      '0800'x 'DATA_RESOURCE_NOT_FOUND',                     /* v3.05 */
      '0804'x 'DATA_RESOURCE_ALREADY_IN_USE',                /* v3.05 */
      '0808'x 'DATA_RESOURCE_NOAUTHORIZATION',               /* v3.05 */
      '0812'x 'DATA_PATH_NOT_FOUND',                         /* v3.05 */
      '0816'x 'PRODUCT_NOT_CONFIGURED',                      /* v3.05 */
      '1200'x 'STORAGE_MEDIUM_EXCEPTION',                    /* v3.05 */
      '1204'x 'DEVICE_NOT_READY',                            /* v3.05 */
      '1208'x 'NOT_ENOUGH_DISKSPACE',                        /* v3.05 */
      '1600'x 'INCORRECT_PROGRAM_INVOCATION',                /* v3.05 */
      '1604'x 'UNEXPECTED_CONDITION',                        /* v3.05 */
      'FE00'x 'SUCCESSFULL_REBOOT',                          /* v3.05 */
      'FE04'x 'SUCCESSFULL_REBOOT_WITH_WARNING',             /* v3.05 */
      'FE08'x 'SUCCESSFULL_REBOOT_WITH_ERRMSG',              /* v3.05 */
      'FE12'x 'SUCCESSFULL_REBOOT_WITH_SERVER_ERRMSG',       /* v3.05 */
                                                             /* v3.05 */
    do i = 1 to words( I!.__cidRCValues ) by 2               /* v3.05 */
      call value 'CIDRC.__' || word( I!.__cidRCValues,i+1 ),,
                 c2d( word( I!.__cidRCValues,i ),2 )         /* v3.05 */
                                                             /* v3.05 */
    end /* do i = 1 to words( I!.__cidRCValues ) by 2 */     /* v3.05 */
                                                             /* v3.05 */
    drop I!.__cidRCValues                                    /* v3.05 */


                        /* xx = next state of the program             */
/*    CIDRC.__successfull_reboot_with_callback = C2D('FFxx'x, 2);     */

                        /* define exit code values                    */
    global.__ErrorExitCode = CIDRC.__unexpected_condition
       global.__OKExitCode = CIDRC.__successful_program_termination

                        /* add the stem CIDRC. to the exposeList      */
    exposeList = exposeList 'CIDRC. '
  end /* if 1 == global.__NeedCID then */

RETURN


/***        End of Part 2 of the source code of TEMPLATE.CMD        ***/

/***       Start of Part 3 of the source code of TEMPLATE.CMD       ***/

/* ------------------------------------------------------------------ */
/*-function:  load a dll                                              */
/*                                                                    */
/*-call:                                                              */
/*   thisRC = LoadDll( registerFunction, dllName, entryPoint,         */
/*                     ,{deRegisterFunction},{checkFunction}          */
/*                     ,{IgnoreRxFuncAddRC},{RegisterErrorRC}         */
/*                     ,{errorAction}                                 */
/*                                                                    */
/*-where:                                                             */
/*         registerFunc = name of the dll init function               */
/*                        (e.g. "SysLoadFuncs")                       */
/*              dllName = name of the dll                             */
/*                        (e.g. "REXXUTIL")                           */
/*           entryPoint = entryPoint for the dll init function        */
/*                        (e.g. "SysLoadFuncs")                       */
/*       deRegisterFunc = name of the dll exit function               */
/*                        (e.g. "SysDropFuncs")                       */
/*                        If this parameter is entered, the           */
/*                        deRegisterFunction is automaticly called    */
/*                        at program end if the loading of the dll    */
/*                        was successfull.                            */
/*            checkFunc = function which must be loaded if the dll is */
/*                        loaded (def.: none -> always load the dll)  */
/*                        Note:                                       */
/*                        Do not use the registerFunction for this    */
/*                        parameter! A good candidate for this        */
/*                        parameter is the deRegisterFunction.        */
/*    IgnoreRxFuncAddRC = 1: ignore the rc from rxFuncAdd             */
/*                        0: do not ignore the rc from rxFuncAdd      */
/*                        (def.: 0)                                   */
/*                        Note: Always set this parameter to 1 if     */
/*                              using the program under WARP.         */
/*       RegisterErroRC = returncode of the dll init function         */
/*                        indicating a load error                     */
/*                        (def. none, -> ignore the returncode of the */
/*                         dll init function)                         */
/*           actionCode = 1: abort program if loading failed          */
/*                        0: do not abort program if loading failed   */
/*                        (def.: 1)                                   */
/*                                                                    */
/*-returns:                                                           */
/*   0 - loading failed                                               */
/*   1 - dll loaded                                                   */
/*   2 - dll already loaded                                           */
/*                                                                    */
/*-Note:                                                              */
/*   See the routine MAIN for some examples for using LoadDLL.        */
/*   LoadDLL can only handle dlls with an init function to register   */
/*   the further routines in the dll (like the function SysLoadFuncs  */
/*   in the dll REXXUTIL).                                            */
/*                                                                    */
LoadDll:  PROCEDURE expose (exposeList)
  parse arg regFunc , ,
            dllName , ,
            entryPoint , ,
            deregFunc , ,
            checkFunc , ,
            ignoreRXFuncAddRC, ,
            registerErrorRC, ,
            errorAction

                        /* check the necessary parameters             */
  if '' == entryPoint | '' == dllName | '' == regFunc then
    call ShowError global.__ErrorExitCode, I!.__GetMsg( 6 )

  if '' == ignoreRXFuncAddRC then
    ignoreRXFuncAddRc = 0

  if '' == errorAction then
    errorAction = 1

  I!.__LoadDLLRc = 0
                        /* if the 'checkFunc' is missing, we          */
                        /* assume that the dll is not loaded          */
  dllNotLoaded = 1
  if ( checkFunc <> '' ) then
    dllNotLoaded = rxFuncQuery( checkFunc )

  if dllNotLoaded then
  do
                        /* first deRegister the function        v3.01 */
    call rxFuncDrop regFunc                                  /* v3.01 */

                        /* load the dll and register the init         */
                        /* function of the dll                        */
    rxFuncAddRC = rxFuncAdd( regFunc, dllName, entryPoint )

    if \ rxFuncAddRC | ignoreRxFuncAddRC then
    do

      I!.__DllInitRC = 0
      if I!.__CallUserProc( 0, regFunc ) == 0 then
        I!.__DllInitRC = 'ERROR'

      if ( registerErrorRC <> '' & I!.__DLLInitRC == registerErrorRC ) | ,
         ( I!.__DllInitRC == 'ERROR' ) then
        nop
      else
      do
                        /* add the dll deregister function to the     */
                        /* program exit routine list                  */
        if DeregFunc <> '' then
          if \ rxFuncQuery( DeregFunc ) then
            prog.__ExitRoutines = prog.__ExitRoutines || ' ' || ,
                                  DeregFunc

        I!.__LoadDLLRc = 1
      end /* else */
    end /* if \ rxFuncAddRC | ignoreRxFuncAddRC then */
  end /* if dllNotLoaded then */
  else
    I!.__LoadDLLRc = 2  /* dll is already loaded                      */

  if 1 == errorAction & 0 == I!.__LoadDLLRC then
    call ShowError global.__ErrorExitCode,,
                   I!.__GetMsg( 5, dllName )

RETURN I!.__LoadDLLRc

/* ------------------------------------------------------------------ */
/*-function: show a string with word wrapping                         */
/*                                                                    */
/*-call:     showString Prefix, thisString                            */
/*                                                                    */
/*-where:                                                             */
/*           Prefix = prefix for the first line (e.g. "*-*" or "#" to */
/*                    use # leading blanks, # = 1 ... n )             */
/*           thisString - string to print                             */
/*                                                                    */
/*-returns:  ''                                                       */
/*                                                                    */
ShowString: PROCEDURE EXPOSE (exposeList)
  parse arg Prefix, thisStr

  maxLineL = prog.__ScreenCols-4

  if datatype( prefix, 'W' ) == 1 then
    prefix = copies( ' ' , prefix )

  maxWordL = maxLineL - length( prefix )

  thisRC = 0
  curStr = ''

  do i = 1 to words( thisStr)
    pStr = 0

    curStr = curStr || word( thisStr, i ) || ' '

    if length( curStr || prefix ||  word( thisStr, i+1 ) ) > maxLineL then
      pStr = 1

    if 1 == pStr | i == words( thisStr ) then
    do
      if length( prefix || curStr ) > prog.__ScreenCols then
      do until curStr = ''
        parse var curStr curStr1 =(maxWordL) ,
                                  curStr
        call log left( prefix || curStr1, prog.__ScreenCols )
        prefix = copies( ' ', length( prefix ) )
      end /* if length( ... then do until */
      else
        call Log left( prefix || curStr, prog.__ScreenCols )

      curStr = ''
      prefix = copies( ' ', length( prefix ) )
    end /* if 1 == pStr | ... */

  end /* do i = 1 to words( thisStr */

RETURN ' '                                                   /* v3.03 */

/* ------------------------------------------------------------------ */
/*-function: show a warning message                                   */
/*                                                                    */
/*-call:     showWarning message                                      */
/*                                                                    */
/*-where:    warningMessage - warning Message                         */
/*                                                                    */
/*-returns:  ''                                                       */
/*                                                                    */
ShowWarning: PROCEDURE expose (exposeList)
  parse arg wMsg

  screen.__CurColor = screen.__ErrorColor

  call I!.__LogStart

  call ShowString I!.__GetMsg( 7 ) || ' ', wMsg || '!'
  call I!.__LogSeparator

  screen.__CurColor = screen.__NormalColor
  call Log

RETURN ' '                                                   /* v3.03 */

/* ------------------------------------------------------------------ */
/*-function: show an error message and end the program                */
/*                                                                    */
/*-call:     ShowError exitCode, errorMessage                         */
/*                                                                    */
/*-where:    ExitCode - no of the error (= program exit code)         */
/*           errorMessage - error Message                             */
/*                                                                    */
/*-returns:  nothing                                                  */
/*                                                                    */
/*-Note:     THIS ROUTINE WILL NOT COME BACK!!!                       */
/*                                                                    */
ShowError: PROCEDURE expose (exposeList)
  parse arg prog.__ExitCode, I!.__errMsg

  I!.__QM = prog.__QuietMode
                        /* turn quiet mode off                        */
  prog.__QuietMode = ''

  screen.__CurColor = screen.__ErrorColor

  call I!.__LogStart

  call Log left( I!.__GetMsg( 8, prog.__Name , prog.__ExitCode ) ,,
                 prog.__ScreenCols )
  call ShowString 1, I!.__errMsg || '!'

  call I!.__LogSeparator
  call Log
                        /* restore quiet mode status                  */
  prog.__QuietMode = I!.__QM

  if prog.__NoSound <> 1 then
  do
    call beep 537,300
    call beep 237,300
    call beep 537,300
  end /* if prog.__NoSound <> 1 then */

  screen.__CurColor = screen.__NormalColor                   /* v3.08 */

SIGNAL I!.__ProgramEnd

RETURN

/* ------------------------------------------------------------------ */
/*-function: log a debug message and clear the rest of the line       */
/*                                                                    */
/*-call:     logDebugMsg message                                      */
/*                                                                    */
/*-where:    message - message to show                                */
/*                                                                    */
/*-returns:  ''                                                       */
/*                                                                    */
/*-Note:     You do not need the 'call' keyword to use this routine.  */
/*                                                                    */
LogDebugMsg: PROCEDURE expose (exposeList)
  if global.__verbose <> '' then
  do
    parse arg dMsg
    screen.__CurColor = screen.__DebugColor
    call Log '+++' dMsg
    screen.__CurColor = screen.__NormalColor
  end /* if global.__verbose <> '' then */
RETURN ' '                                                   /* v3.03 */

/* ------------------------------------------------------------------ */
/*-function: write a CR/LF and a separator line to the screen and to  */
/*           the logfile                                              */
/*                                                                    */
/*-call:     I!.__LogStart                                            */
/*                                                                    */
/*-returns:  nothing                                                  */
/*                                                                    */

/* ------------------------------------------------------------------ */
/*-function: write a separator line to the screen and to the logfile  */
/*                                                                    */
/*-call:     I!.__LogSeparator                                        */
/*                                                                    */
/*-returns:  nothing                                                  */
/*                                                                    */
I!.__LogStart:
  call log
I!.__LogSeparator:
  call Log ' ' || left('-', prog.__ScreenCols-2, '-' ) || ' '
RETURN

/* ------------------------------------------------------------------ */
/*-function: log a message and clear the rest of the line             */
/*                                                                    */
/*-call:     log message                                              */
/*                                                                    */
/*-where:    message - message to show                                */
/*                                                                    */
/*-returns:  ''                                                       */
/*                                                                    */
/*-Note:     You do not need the 'call' keyword to use this routine.  */
/*                                                                    */
Log: PROCEDURE expose (exposeList)
  parse arg msg

  logmsg = msg
  do i = 1 to words( prog.__LogExcludeWords )
    curWord = word( prog.__LogExcludeWords, i )
   
    do until j = 0
      j = Pos( curWord, logmsg )
      if j <> 0 then
        logmsg = delstr( logmsg, j, length( curWord ) )
    end /* do until j = 0 */
  end /* do i = 1 to words( prog.__LogExcludeWords ) */

  if prog.__QuietMode <> 1 then
  do

    if length( logmsg ) == prog.__ScreenCols  then
      call charout prog.__STDOUT, screen.__CurColor || ,
                                  msg || screen.__AttrOff
    else
      call lineOut prog.__STDOUT, screen.__CurColor || ,
                                  msg || screen.__AttrOff ||,
                                  screen.__DelEOL

  end /* if prog.__Quietmode <> 1 then */

  if symbol( 'prog.__LogFile' ) == 'VAR' then
    if prog.__LogFile <> '' then
    do
      call lineout prog.__LogFile, logmsg

                                /* close the logfile                  */
      call stream prog.__LogFile, 'c', 'CLOSE'
    end /* if prog.__LogFile <> '' then */

RETURN ' '                                                   /* v3.03 */

/* ------------------------------------------------------------------ */
/*-function: check if there is a patched version of this program      */
/*                                                                    */
/*-call:     I!.__CheckPatch                                          */
/*                                                                    */
/*-returns:  nothing                                                  */
/*                                                                    */
/*-Note:     I!.__RealParam must contain the parameters for           */
/*           this program.                                            */
/*           The variables prog.__Path and prog.__Name must be set!   */
/*           This procedure ends the program with an EXIT command!    */
/*                                                                    */
I!.__CheckPatch: PROCEDURE expose (exposeList)

                        /* get the drive with patch cmd files         */
                        /*                                      v3.04 */
  parse upper value value( 'PATCHDRIVE',, prog.__env ) with pLW

  if global.__NeedPatchCheck <> 0 & ( pLW <> '' & pLW <> prog.__Drive ) then
  do

    pVer = pLW || prog.__Path || prog.__Name

                        /* check if a patched program version exists  */
    if stream( pVer, 'c', 'QUERY EXIST' ) <> '' then
    do
      pCmd = pVer || ' ' || I!.__RealParam

      screen.__CurColor = screen.__PatchColor
      call Log left( I!.__GetMsg( 9, pver ), prog.__ScreenCols )
      screen.__CurColor = screen.__AttrOff
      call I!.__LogSeparator

      '@cmd /c ' pCmd

      screen.__CurColor = screen.__AttrOff
      call I!.__LogSeparator
      screen.__CurColor = screen.__PatchColor
      call Log left( I!.__GetMsg( 10, rc ), prog.__ScreenCols )

      exit rc
    end /* if stream( ... */
  end /* if pLW <> '' */
RETURN

/* ------------------------------------------------------------------ */
/*-function: error handler for unexpected errors                      */
/*                                                                    */
/*-call:     DO NOT CALL THIS ROUTINE BY HAND!!!                      */
/*                                                                    */
/*-returns:  nothing                                                  */
/*                                                                    */
/*-input:    I!.__IncActive:                                          */
/*             if 1 the error occured while executing an include file */
/*             statement. In this case the following variables are    */
/*             also used (Note that this variables are automaticly    */
/*             set by the routine INCLUDE()):                         */
/*               I!.__IncLineNo                                       */
/*                 Line no. of the include file                       */
/*               I!.__IncFileName:                                    */
/*                 Name of the include file                           */
/*               I!.__IncCurLinePos:                                  */
/*                 Fileposition of the first char of the line causing */
/*                 the error                                          */
/*                                                                    */
/*-Note:     THIS FUNCTION ABORTS THE PROGRAM WITH A JUMP TO THE      */
/*           LABEL I!.__PROGRAMEND!!!                                 */
/*                                                                    */
I!.__ErrorAbort:

                            /* turn ANSI word wrap on                 */   
  if screen.__CurColor <> '' then
    call CharOut prog.__STDOUT, '1B'x || '[7h'

                        /* check if the error occured in the error    */
                        /* handler                                    */
  if I!.__errorLineNo == sigl then
  do
    call charout 'STDERR:',,
                                                            '0D0A'x  ,
       'Fatal Error: Error in the error handler detected!'  '0D0A'x  ,
                                                            '0D0A'x  ,
       'Linenumber:       ' || sigl                         '0D0A'x  ,
       'Errorname:        ' || condition('C')               '0D0A'x  ,
       'Errordescription: ' || condition('D')               '0D0A'x  ,
                                                            '0D0A'x  ,
       'The program exit routines were not called!'         '0D0A'x  ,
       'Check if "(EXPOSELIST)" is included in the ' || ,
       'expose lists of all procedures!'                    '0D0A'x

    call beep 637,300 ; call beep 437,300 ; call beep 637,300
    exit 255

  end /* if I!.__errorLineNo == sigl then */

                        /* get the number of the line causing the     */
                        /* error                                      */
  I!.__errorLineNo = sigl

                        /* get the name of this error                 */
  I!.__ErrorName = condition('C')

                        /* get further information for this error     */
                        /* if available                               */
  I!.__ErrorCondition = condition('D')
  if I!.__ErrorCondition <> '' then
    I!.__ErrorCondition = ' (Desc.: "' || I!.__ErrorCondition || '")'

  if datatype( prog.__ScreenCols, 'W' ) <> 1 then
    prog.__ScreenCols = 80

  if SYMBOL( 'prog.__Name' ) <> 'VAR' | value( 'prog.__Name' ) == '' then
    if I!.__errorLineNO < I!.__FirstUserCodeLine then
      I!.__pName = '**Runtime**'
    else
      I!.__pName = '***???***'
  else
    i!.__pName = prog.__Name

                        /* reInstall the error handler                */
  INTERPRET  'SIGNAL ON ' value(condition('C')) ' NAME I!.__ErrorAbort'

                        /* check, if we should ignore the error       */
  if value( 'sigl' ) == value( 'I!.__ICmdLine' ) then
  do
    I!.__errorLineNo = 0
    SIGNAL I!.__CallUserProc2
  end /* if value( ... */

  screen.__CurColor = screen.__ErrorColor

  I!.__QM = prog.__QuietMode
                        /* turn quiet mode off                        */
  prog.__QuietMode = ''

                        /* init variables for printing the line       */
                        /* causing the error to the screen            */
  I!.__ThisSRCLine = ''
  I!.__ThisPrefix = ' *-* '

  call I!.__LogStart

  call ShowString ' ' || I!.__pName || ' - ', I!.__ErrorName || ,
                  I!.__ErrorCondition || ' error detected!'

                        /* check, if the RC is meaningfull for this   */
                        /* error                                      */
  if pos( I!.__ErrorName, 'ERROR FAILURE SYNTAX' ) <> 0 then
  do
    if datatype(rc, 'W' ) == 1 then
      if 'SYNTAX' == I!.__ErrorName then
         if rc > 0 & rc < 100 then
            call Log left( ' The error code is ' || rc || ,
                           ', the REXX error message is: ' || ,
                           errorText( rc ), ,
                           prog.__ScreenCols )
         else
           call log left( ' The error code is ' || rc || ,
                          ', this error code is unknown.',,
                          prog.__ScreenCols )
      else
        call Log left( ' The RC is ' || rc || '.', prog.__ScreenCols )
  end /* if pos( ... */

  if value( 'I!.__IncActive' ) == 1 then
  do
                /* error occured while interpreting an include file   */
    call ShowString 1, 'The error occured while executing the line ' || ,
                       I!.__IncLineNo || ' of the include file "' || ,
                       I!.__IncFileName || '".'

                        /* reset the file pointer of the include file */
                        /* to the start of the line causing the error */
    call stream I!.__IncFileName, 'c', 'SEEK =' || ,
                                                   I!.__IncCurLinePos

    I!.__SrcAvailable = stream( I!.__IncFileName, ,
                                   'c', 'QUERY EXIST' ) <> ''
  end
  else
  do
    call ShowString 1, 'The error occured in line ' ||,
                       I!.__errorLineNo || '.'

    I!.__thisLineNo = I!.__errorLineNo

                /* error occured in this file                         */
                /* check if the sourcecode is available               */
    SIGNAL ON SYNTAX   NAME I!.__NoSourceCode
    I!.__inMacroSpace = 1
    I!.__SrcAvailable = 0
    if sourceLine( I!.__errorLineNo ) <> '' then
      I!.__SrcAvailable = 1

    SIGNAL ON SYNTAX NAME I!.__ErrorAbort
    I!.__inMacroSpace = 0

  end /* else */

                        /* print the statement causing the error to   */
                        /* the screen                                 */
  if 1 == I!.__SrcAvailable then
  do
    call Log left( ' The line reads: ', prog.__ScreenCols )
    I!.__InterpretVar = 0

                /* read the line causing the error                    */
    call I!.__GetSourceLine

    I!.__FirstToken = strip(word( I!.__ThisSRCLine,1))
    if translate( I!.__FirstToken ) == 'INTERPRET' then
    do
      parse var I!.__ThisSRCLine (I!.__FirstToken) ,
                I!.__interpretValue
      I!.__InterpretVar = 1
    end /* if I!.__thisLineNo = I!.__errorLineNo */

                        /* handle multi line statements               */
    do forever
      call ShowString I!.__ThisPrefix, I!.__ThisSRCLine

      if right( strip( I!.__ThisSRCLine),1 ) <> ',' then
        leave

      I!.__ThisPrefix = 5

      call I!.__GetSourceLine
    end /* do forever */

    if 1 == I!.__InterpretVar then
    do
      I!.__interpretValue = strip( word(I!.__interpretValue,1) )

      if symbol( I!.__interpretValue ) == 'VAR' then
      do
        call Log left( '', prog.__ScreenCols )
        call Log left( ' The value of "' || I!.__interpretValue || ,
                       '" is:', prog.__ScreenCols )
        call ShowString ' >V> ', value( I!.__interpretValue )
      end /* if symbol( I!.__interpretValue ) = 'VAR' then */

    end /* if 1 == I!.__InterpretVar */

  end /* if 1 == I!.__SrcAvailable  then do */
  else
    call Log left( ' The sourcecode for this line is not available',,
                   prog.__ScreenCols )

I!.__NoSourceCode:
  SIGNAL ON SYNTAX NAME I!.__ErrorAbort

  if 1 == I!.__inMacroSpace then
  do
    parse source . . I!.__thisProgName

    if fileSpec( 'D', I!.__thisProgName ) == '' then
      call ShowString 1, ' The sourcecode for this line is not' || ,
                         ' available because the program is in' || ,
                         ' the macro space.'
    else
      call ShowString 1, ' The sourcecode for this line is not' || ,
                         ' available because the program is unreadable.'
  end /* if 1 == I!.__inMacroSpace then */

  call I!.__LogSeparator
  call Log

  prog.__ExitCode = global.__ErrorExitCode

  if prog.__NoSound <> 1 then
  do
    call beep 137,300;  call beep 337,300;  call beep 137,300
  end /* if prog.__NoSound <> 1 then */

  if 'DEBUG' == global.__verbose | prog.__Trace = 1 then
  do
                        /* enter interactive debug mode               */
    trace ?a
    nop
  end /* if 'DEBUG' == global.__verbose | ... */

                        /* restore quiet mode status                  */
  prog.__QuietMode = I!.__QM
                        /* restore current color                      */
  screen.__CurColor = screen.__NormalColor                   /* v3.08 */

SIGNAL I!.__programEnd

/* ------------------------------------------------------------------ */
/*-function: get the sourceline causing an error (subroutine of       */
/*           I!.__ErrorAbort)                                         */
/*                                                                    */
/*-call:     DO NOT CALL THIS IN YOUR CODE!!!                         */
/*                                                                    */
/*-returns:  nothing                                                  */
/*                                                                    */
/*-Note:     -                                                        */
/*                                                                    */
I!.__GetSourceLine:
  if 1 == I!.__IncActive then
    I!.__ThisSRCLine = lineIn( I!.__IncFileName )
  else
  do
    I!.__ThisSRCLine = sourceLine( I!.__ThisLineNo )
    I!.__ThisLineNo = I!.__ThisLineNo + 1
  end /* else */
RETURN

/* ------------------------------------------------------------------ */
/*-function: error handler for user breaks                            */
/*                                                                    */
/*-call:     DO NOT CALL THIS ROUTINE BY HAND!!!                      */
/*                                                                    */
/*-returns:  nothing                                                  */
/*                                                                    */
/*-Note:     THIS FUNCTION ABORTS THE PROGRAM WITH A JUMP TO THE      */
/*           LABEL I!.__PROGRAMEND IF prog.__UserAbort IS NOT 0!!!    */
/*                                                                    */
/*           In exit routines you may test if the variable            */
/*           prog.__ExitCode is 254 to check if the program           */
/*           was aborted by the user.                                 */
/*                                                                    */
I!.__UserAbort:
  I!.__sSigl = sigl

                        /* reinstall the error handler                */
  CALL ON HALT NAME I!.__UserAbort

                        /* check if user aborts are allowed           */
  if 0 == prog.__UserAbort then
    RETURN              /* CTRL-BREAK not allowed                     */

  I!.__QM = prog.__QuietMode

                        /* turn quiet mode off                        */
  prog.__QuietMode = ''

  call Log

  screen.__CurColor = screen.__ErrorColor
  call I!.__LogSeparator
  call Log left( I!.__GetMsg( 11, I!.__sSigl ), prog.__ScreenCols )
  call I!.__LogSeparator
  screen.__CurColor = screen.__NormalColor

  prog.__ExitCode = 254

                        /* restore quiet mode status                  */
  prog.__QuietMode = I!.__QM

SIGNAL I!.__ProgramEnd

/* ------------------------------------------------------------------ */
/*-function: get a message                                            */
/*                                                                    */
/*-call:     I!.__GetMsg msgNo {,msgP1} {...,msgP9}                   */
/*                                                                    */
/*-returns:  the message or an empty string                           */
/*                                                                    */
/*-note:     This routines calls the external routine which name is   */
/*           saved in the variable 'global.__GetMsg' if this variable */
/*           is not equal ''.                                         */
/*                                                                    */
/*           I!.__GetMsg adds global.__BaseMsgNo to the msgNo.        */
/*                                                                    */
I!.__GetMsg: PROCEDURE expose (exposeList)
  parse arg msgNo, mP1 , mP2 , mP3, mP4, mP5, mP6, mP7, mP8, mP9

  f = 0
  t = ''

  if symbol( 'global.__GetMsg' ) = 'VAR' then
    if global.__GetMsg <> '' then
    do
            /* first check if there's a user defined GetMsg routine   */

                        /* install a local error handler              */
      SIGNAL ON SYNTAX Name I!.__GetMsg1

                    /* try to call the user defined GetMsg routine    */
      interpret 'call ' global.__GetMsg ' msgNo+global.__BaseMsgNo,,' ,
                ' mP1, mP2, mP3, mP4, mP5, mP6, mP7, mP8, mP9 '
      f = 1
    end /* if global.__GetMsg <> '' then */

I!.__GetMsg1:

  if f = 1 then
  do
                        /* user defined GetMsg routine found -- use   */
                        /* the result                                 */
    if symbol( 'RESULT' ) == 'VAR' then
      t = result
  end /* if result = 0 then */
  else
  do
                        /* user defined GetMsg routine not found --   */
                        /* use the hardcoded message strings          */
      msgString =  ,
/* 1001 */      'Routine_"@1"_not_found',
/* 1002 */      'Can_not_write_to_the_logfile_"@1",_the_status_of_the_logfile_is_"@2"._Now_using_the_NUL_device_for_logging',
/* 1003 */      'Include_file_"@1"_not_found' ,
/* 1004 */      'Unexpected_EOF_detected_while_reading_the_include_file_"@1"' ,
/* 1005 */      'Error_loading_the_DLL_"@1"' ,
/* 1006 */      'Invalid_call_to_LOADDLL' ,
/* 1007 */      '_Warning:' ,
/* 1008 */      '_@1_-_Error_@2_detected!_The_error_message_is_',
/* 1009 */      '_Calling_the_patched_version_@1_...' ,
/* 1010 */      '_..._the_patched_version_endet_with_RC_=_@1' ,
/* 1011 */      '_Program_aborted_by_the_user_(sigl=@1)' ,
/* 1012 */      '@1_@2_started_on_@3_at_@4_...' ,
/* 1013 */      '@1_@2_ended_on_@3_at_@4_with_RC_=_@5_(=''@6''x)' ,
/* 1014 */      '_Usage:'

                    /* get the message and translate all underscores  */
                    /* to blanks                                      */
    t = translate( word( msgString, msgNo ), ' ', '_'  )

                    /* replace place holder                           */
    i = 1
    do until i > 9
     j = pos( '@' || i, t )
     if j <> 0 then
       t = insert( arg( i+1 ), delStr(t, j, 2) , j-1 )
     else
       i = i +1
    end /* do until i > 9 */
  end /* else */
return t

/* ------------------------------------------------------------------ */
/*-function: get the line no of the call statement of this routine    */
/*                                                                    */
/*-call:     GetLineNo                                                */
/*                                                                    */
/*-returns:  the line number                                          */
/*                                                                    */
/*                                                                    */
GetLineNo:
  RETURN sigl

/* ------------------------------------------------------------------ */
/*-function: get the no. of the first line with the user code         */
/*                                                                    */
/*-call:     DO NOT CALL THIS ROUTINE BY HAND!!!                      */
/*                                                                    */
/*-returns:  nothing                                                  */
/*                                                                    */
/*                                                                    */
I!.__GetUserCode:
  I!.__FirstUserCodeLine = GetLineNo()+2
RETURN

/********************** End of Runtime Routines ***********************/
/**********************************************************************/

/***        End of Part 3 of the source code of TEMPLATE.CMD        ***/
/***       Start of Part 4 of the source code of TEMPLATE.CMD       ***/
                                                                   /*!*/

/* ------------------------------------------------------------------ */
/*-function: main procedure of the program                            */
/*                                                                    */
/*-call:     called by the runtime system with:                       */
/*           => call main parameter_of_the_program <=                 */
/*                                                                    */
/*-returns:  program return code                                      */
/*           If no return code is returned, the value of the variable */
/*           prog.__ExitCode is returned to the calling program.      */
/*                                                                    */
/*-Note:     YOU MUST FILL THIS ROUTINE WITH CODE.                    */
/*           If you want to add further global variables you SHOULD   */
/*           add them to the expose list of the procedure MAIN!       */
/*                                                                    */
Main: PROCEDURE expose (exposeList)

                    /* not used in this program                       */
  parse arg template
       
                    /* turn off the REXX error handling               */
  signal off failure
  signal off error
  signal off notready

                    /* used colors in this program                    */
                    /* (the variable is used by the routine log)      */
  prog.__LogExcludeWords = ,
                           screen.__ErrorColor ,
                           screen.__NormalColor ,
                           screen.__DebugColor ,
                           screen.__PromptColor ,
                           screen.__SignOnColor ,
                           screen.__fgYellow ,
                           screen.__fgRed ,
                           screen.__highlight ,
                           screen.__AttrOff ,

/* ------------------------------ */
                    /* prefixes for the different message types       */
  statusPrefix = '[---] ' 
  resultPrefix = '      '
  errorPrefix  = '[-!-] '
  inputPrefix = ' ===>  '

  exposeList = exposeList 'statusPrefix resultPrefix ' ,
                          'errorPrefix inputPrefix'

                    /* the name of the cdrom device                   */
  global.__cddevice = 'cdaudio01'

                    /* MCI error code                                 */
  global.__mmpmerror = 0

  call DisplayStatusMessage 'Initialising ...'

                    /* load the MMOS/2 REXX support                   */
  call DisplayStatusMessage 'Loading the MMOS/2 DLL ...'
  thisRC = LoadMCIRxInit()
  call ShowMCIErrorDesc thisRC

                    /* add the exit routine to the program exit       */
                    /* code                                           */
  prog.__exitRoutines = prog.__exitRoutines 'ExitMCI'

                    /* open the cdrom device                          */
  call DisplayStatusMessage 'Opening the cdrom device ...'
  thisRC = OpenCDDevice()
  call ShowMCIErrorDesc thisRC

                    /* read the cdrom data                            */
  call DisplayStatusMessage  'Reading the cdrom ... '
  call ReReadCD

                    /* main program loop                              */
  do forever
                    /* get the status of the device                   */
    curResult = GetDeviceStatus()
    if curResult = '' then
      call ShowMCIErrorDesc global.__mmpmError
    else
      call DisplayStatusMessage 'The device is ' || ,
                               AddColor1( , curResult )

                    /* read the user input                            */
    call log  screen.__PromptColor || ,
          'Please enter a command (help to get help, quit to leave):' ,
              screen.__NormalColor

    call CharOut , InputPrefix
    curCmd = cmdLine()

                    /* write the userinput to the logfile             */
    temp = prog.__QuietMode
    prog.__QuietMode = 1
    call log inputPrefix || curCmd
    prog.__QuietMode = temp

    parse upper var curCmd curCommand curParameter
    parse var curCmd firstChar +1 extCommand

    select

      when curCommand = '' then
      do
        nop
      end /* when */

      when abbrev( 'QUIT', curCommand ) = 1 then
      do
                    /* exit the program                               */
        leave
      end /* when */

      when abbrev( 'ERROR', curCommand ) = 1 then
      do
                    /* show the description for an MCI error code     */
        call ShowMCIErrorDesc curParameter
      end /* when */

      when abbrev( 'VOLUME', curCommand ) = 1 then
      do
                    /* read or set the volume                         */
        select

          when curParameter = '' then
          do
                    /* read the current volume                        */
            call DisplayStatusMessage 'Inquiring the volume ...'
            curResult = GetVolume()
            if curResult = '' then
            do
              call ShowMCIErrorDesc global.__mmpmError
            end /* if */
            else
              call DisplayResultMessage 'The volume is ' || ,
                                        AddColor1( , curResult )
          end /* if */

          when datatype( curParameter ) <> 'NUM' then
          do
            call DisplayErrorMsg 'Invalid parameter entered'
          end /* if */

          when  curParameter > 100 | curParameter < 0 then
          do
            call DisplayErrorMsg 'Parameter out of range'
          end /* if */

          otherwise
          do
            call DisplayStatusMessage 'Settting the volume to ' || ,
                            curParameter || ':' || curParameter ||  ' ...'
            call SetVolume curParameter
            call ShowMCIErrorDesc global.__mmpmError

          end /* otherwise */

        end /* select */

      end /* when */


      when abbrev( 'TRY', curCommand ) = 1 then
      do
                    /* play the start of each track on the cd         */
        if curParameter = '' | datatype( curParameter ) <> 'NUM' then
          curParameter = 10

        call TryCD curParameter
      end /* when */

      when abbrev( 'PLAY', curCommand ) = 1 then
      do
                    /* play one or more tracks from the cd            */
        parse var curParameter startTrack endTrack

        if starttrack = '' then
        do
                    /* def.: play all tracks                          */
          startTrack = 1
          endTrack = '+'
        end /* if */

        if endTrack = '+' then
          endTrack = 100

        call PlayTracks startTrack, endTrack
      end /* when */

      when abbrev( 'STOP', curCommand ) = 1 then
      do
                    /* stop the device                                */
        call DisplayStatusMessage  'Stopping the device ...'
        curResult = StopDevice()
        call ShowMCIErrorDesc global.__mmpmError
      end /* when */

      when abbrev( 'SOUND', curCommand ) = 1 then
      do
                    /* turn the speaker on or off                     */
        select

          when curParameter = 'ON' | curParameter = '' then
          do
            call DisplayStatusMessage 'Turning the sound on'
            call SetSoundOn
            call ShowMCIErrorDesc global.__mmpmError
          end /* when */

          when curParameter = 'OFF' then
          do
            call DisplayStatusMessage 'Turning the sound off'
            call SetSoundOff
            call ShowMCIErrorDesc global.__mmpmError
          end /* when */

          otherwise
            call DisplayErrorMessage 'Invalid parameter (use ON or OFF)'

        end /* select */

      end /* when */

      when abbrev( 'PAUSE', curCommand ) = 1 then
      do
                    /* pause the device                               */
        call DisplayStatusMessage  'Pausing the device ...'
        curResult = PauseDevice()
        call ShowMCIErrorDesc global.__mmpmError
      end /* when */

      when abbrev( 'RESUME', curCommand ) = 1 then
      do
                    /* resume the device                              */
        call DisplayStatusMessage  'Resuming the device ...'
        curResult = ResumeDevice()
        call ShowMCIErrorDesc global.__mmpmError
      end /* when */

      when abbrev( 'EJECT', curCommand ) = 1 then
      do
                    /* eject the CD                                   */
        call DisplayStatusMessage  'Opening the cd drive ...'
        curResult = OpenCDDrive()
        call ShowMCIErrorDesc global.__mmpmError
      end /* when */

      when abbrev( 'LOAD', curCommand ) = 1 then
      do
                    /* close the cdrom                                */
        call DisplayStatusMessage  'Closing the CD drive ...'
        curResult = CloseCDDrive()
        call ShowMCIErrorDesc global.__mmpmError
      end /* when */

      when abbrev( 'DIR', curCommand ) = 1 then
      do
                    /* show the contents of the cd                    */
        call DirCD
      end /* when */

      when abbrev( 'REREAD', curCommand ) = 1 then
      do
                    /* "reread" the cd                                */
        call DisplayStatusMessage  'Reading the cd ...'
        call ReReadCD
      end /* when */

      when abbrev( 'DEBUG', curCommand ) = 1 then
      do
                    /* interactive enter MCI commands                 */
        call TestMCI
      end /* when */

      when abbrev( 'CMD', curCommand ) = 1 then
      do
                    /* execute an OS command                          */
        call ExecuteOSCommand curParameter
      end /* when */

      when firstChar = '!' then
      do
                    /* execute an OS command                          */
        call ExecuteOSCommand extCommand
      end /* when */

      when firstChar = '#' then
      do
                    /* execute a REXX command                         */
        call InterpretCommand extCommand
      end /* when */

      when abbrev( 'HELP', curCommand ) = 1 then
      do
                    /* show the online help                           */
         call ShowOnlineHelp
      end /* when */

      when abbrev( 'SAMPLES', curCommand ) = 1 then
      do
                    /* show usage samples                             */
         call ShowSamples
      end /* when */

      otherwise
      do
        call DisplayErrorMessage 'Unknown command "' || curCommand || '"'
      end /* otherwise */

    end /* select */

  end /* do forever */

                        /* close the cdrom device                     */
  call DisplayStatusMessage  'Closing ...'
  thisRC = CloseCDDevice()
  call ShowMCIErrorDesc thisRC

/* ------------------------------ */

                        /* exit the program                           */
                        /* Note: The program exit code is the return  */
                        /*       code of the routine MAIN             */
                        /*       If MAIN returns nothing, the program */
                        /*       exit code is the current value of    */
                        /*       the variable "prog.__ExitCode" after */
                        /*       executing MAIN.                      */
RETURN

/* ------------------------------------------------------------------ */

/*** INSERT FURTHER SUBROUTINES HERE ***/

/*** Note: Do not forget the string 'EXPOSELIST' in the exposeList  ***/
/***       of ALL procedures!                                       ***/

/* ------------------------------------------------------------------ */
/*-function: Show the invocation syntax                               */
/*                                                                    */
/*-call:     called by the runtime system with                        */
/*           => call ShowUsage <=                                     */
/*                                                                    */
/*-where:    -                                                        */
/*                                                                    */
/*-returns:  ''                                                       */
/*                                                                    */
/*-Note:     YOU SHOULD FILL THIS ROUTINE WITH CODE.                  */
/*           You may change the return code for your program in this  */
/*           routine. The default for the return code is 253.         */
/*           (The variable for the return code is prog.__ExitCode)    */
/*                                                                    */
/*                                                                    */
ShowUsage: PROCEDURE expose (exposeList)
  call ShowString I!.__GetMsg( 14 ) || ' ' ,,                /* v3.06 */
                  prog.__name ,                              /* v3.06 */
                  global.__userUsage prog.__DefParms         /* v3.06 */

RETURN ' '                                                   /* v3.03 */

/* ------------------------------------------------------------------ */
/* Function: add quote chars and color codes to a string              */
/*                                                                    */
/* call:     AddColor1( quoteChar ,myString )                         */
/*                                                                    */
/* where:    quoteChar - leading and trailing character for the       */
/*                       converted string (may be ommited)            */
/*           myString - string to convert                             */
/*                                                                    */
/* returns:  converted string                                         */
/*                                                                    */
/* note:     Add the color codes used in this routine to the          */
/*           variable 'prog.__LogExcludeWords' if you don't want      */
/*           them in the logfile. Example:                            */
/*                                                                    */
/*               prog.__LogExcludeWords = screen.__fgYellow ,         */
/*                                        screen.__highlight ,        */
/*                                        screen.__AttrOff            */
/*                                                                    */
/*           This should be one of the first statements in the        */
/*           routine main.                                            */
/*                                                                    */
AddColor1: PROCEDURE expose (exposeList)
  parse arg quoteChar, myString

return quoteChar || screen.__fgYellow || screen.__highlight || ,
       myString || ,
      screen.__AttrOff || quoteChar

/* ------------------------------------------------------------------ */
/* Function: add quote chars and color codes to a string              */
/*                                                                    */
/* call:     AddColor2( quoteChar ,myString )                         */
/*                                                                    */
/* where:    quoteChar - leading and trailing character for the       */
/*                       converted string (may be ommited)            */
/*           myString - string to convert                             */
/*                                                                    */
/* returns:  converted string                                         */
/*                                                                    */
/* note:     Add the color codes used in this routine to the          */
/*           variable 'prog.__LogExcludeWords' if you don't want      */
/*           them in the logfile. Example:                            */
/*                                                                    */
/*               prog.__LogExcludeWords = screen.__fgRed ,            */
/*                                        screen.__highlight ,        */
/*                                        screen.__AttrOff            */
/*                                                                    */
/*           This should be one of the first statements in the        */
/*           routine main.                                            */
/*                                                                    */
AddColor2: PROCEDURE expose (exposeList)
  parse arg quoteChar, myString

return quoteChar || screen.__fgRed || screen.__highlight || ,
       myString || ,
      screen.__AttrOff || quoteChar

/* ------------------------------------------------------------------ */
/* NOTE: You must uncomment this routines before using them!!!        */

/*** DEBUGGING SUBROUTINES ***/

/**DEBUG** Delete this line before using the debugging routines!!!

/* ------------------------------------------------------------------ */
/* function: show all variables defined for the routine calling       */
/*           this routine.                                            */
/*                                                                    */
/* call:     ShowDefinedVariables {N} {,varMask} {,outpufFile}        */
/*                                                                    */
/* where:    N - no pause if the screen is full                       */
/*           varMask - mask for the variables                         */
/*           outputFile - write the variable list to this file        */
/*                                                                    */
/* returns:  nothing                                                  */
/*                                                                    */
/* note:     This routine needs the Dave Boll's DLL RXU.DLL!          */
/*           Be aware that the special REXX variables SIGL, RC and    */
/*           RESULT are changed if you call this routine!             */
/*                                                                    */
/*                                                                    */
ShowDefinedVariables:
  parse upper arg SDV.__pauseMode, SDV.__varMask, SDV.__outPut

                                /* install a local error handler      */
  signal on syntax name SDV.__RXUNotFound

                                /* load the necessary DLL function    */
  call rxFuncDrop 'RxVLIst'
  call rxFuncAdd 'RxVlist', 'RXU', 'RxVList'

  call rxFuncDrop 'RxPullQueue'
  call rxFuncAdd 'RxPullQueue', 'RXU', 'RxPullQueue'

                                /* create a queue for the variables   */
  SDV.__newQueue = rxqueue( 'create' )

                                /* the 'D' parameter of the RxVList   */
                                /* functions won't pause if the       */
                                /* screen is full                     */
  SDV.__thisRC = RxVList( SDV.__varMask, 'V' , SDV.__newQueue )

                                /* ignore local variables of this     */
                                /* routine                            */
  SDV.__thisRC = SDV.__thisRC

  call LineOut SDV.__outPut , '  ' || copies( '',76 )

  if SDV.__thisRC <> 0 then
  do

    call LineOut SDV.__outPut , '  Defined variable(s) and their values:'
    SDV.__i = 0

    do SDV.__n = 1 to SDV.__ThisRC
      if SDV.__i >= 23 & ,
         SDV.__pauseMode <> 'N' then
      do
        ADDRESS 'CMD' 'PAUSE'
        SDV.__i = 0
      end /* if */
      SDV.__varName = RxPullQueue( SDV.__newQueue, 'Nowait', 'SDV.__dummy' )
      SDV.__varValue = RxPullQueue( SDV.__newQueue, 'Nowait', 'SDV.__dummy' )

                                /* ignore local variables of this     */
                                /* routine                            */
      if left( SDV.__varName, 6 ) <> 'SDV.__' then
      do
        call LineOut SDV.__outPut , '     ' || SDV.__varName || ' = "' || SDV.__varValue || '"'
        SDV.__i = SDV.__i+1
      end /* if right( ... */

    end /* do */

                        /* delete the queue for the variables         */
    call rxqueue 'Delete', SDV.__newQueue
  end
  else
    call LineOut SDV.__outPut , '  No variables defined.'

  call LineOut SDV.__outPut , '  ' || copies( '',76 )

                        /* close the file                             */
  call LineOut SDV.__Output

                        /* delete local variables                     */
  drop SDV.
RETURN ' '                                                   /* v3.03 */

                        /* error exit for ShowDefinedVariables        */
SDV.__RXUNotFound:
  call LineOut SDV.__outPut , 'ShowDefinedVariables: RXU.DLL not found'
RETURN 255

NoValue:
  say 'sigl = 'sigl
  say 'condition(D) ' condition('D')
  trace ?a; nop

   Delete this line before using the debugging routines!!!    **DEBUG**/

/***        End of Part 4 of the source code of TEMPLATE.CMD        ***/
/**********************************************************************/

/* ------------------------------------------------------------------ */
/*-function: (Re)Read the cdrom                                       */
/*                                                                    */
/*-call:     ReReadCD                                                 */
/*                                                                    */
/*-where:    -                                                        */
/*                                                                    */
/*-returns:  0 if successfull                                         */
/*                                                                    */
/*-Note:     -                                                        */
/*                                                                    */
ReReadCD: PROCEDURE expose (exposeList)

  thisRC = 0

  if thisRC = 0 then
  do
    call DisplayStatusMessage ,
           'Inquiring the product status of the cdrom drive ...'
    cdromDesc = GetCDRomDescription()
    if cdromDesc = '' then
    do
      call ShowMCIErrorDesc global.__mmpmError
      thisRC = -1
    end /* if */
    else
      call DisplayResultMessage ,
               'The product information for the cdrom drive is ' || ,
               AddColor1( , cdRomDesc )
  end /* if */

  if thisRC = 0 then
  do
    call DisplayStatusMessage 'Checking the status of the device ...'
    curResult = GetDeviceStatus()
    if curResult = '' then
    do
      call ShowMCIErrorDesc global.__mmpmError
      thisRC = -1
    end /* if */
    else
      call DisplayResultMessage 'The device is ' || ,
                                AddColor1( , curResult )
  end /* if */

  if thisRC = 0 then
  do
    call DisplayStatusMessage 'Inquiring the volume ...'
    curResult = GetVolume()
    if curResult = '' then
    do
      call ShowMCIErrorDesc global.__mmpmError
      thisRC = -1
    end /* if */
    else
      call DisplayResultMessage 'The volume is ' || ,
                                AddColor1( , curResult )
  end /* if */

  if thisRC = 0 then
  do
    curResult = GetCurrentPosition()
    if curResult = '' then
    do
      call ShowMCIErrorDesc global.__mmpmError
      thisRC = -1
    end /* if */
    else
      call DisplayResultMessage 'The current position is ' || ,
                                AddColor1( , curResult )
  end /* if */

  if thisRC = 0 then
  do
    curResult = GetNumberOfTracks()
    if curResult = '' then
    do
      call ShowMCIErrorDesc global.__mmpmError
      thisRC = -1
    end /* if */
    else
      call DisplayResultMessage 'There are ' || ,
                                AddColor1( , curResult ) || ,
                                ' tracks on the CD'
  end /* if */

  if thisRC = 0 then
  do
    curResult = GetNumberOfTheCurrentTrack()
    if curResult = '' then
    do
      call ShowMCIErrorDesc global.__mmpmError
      thisRC = -1
    end /* if */
    else
    do
      curTrack = curResult
      call DisplayResultMessage 'The current track is ' || ,
                                AddColor1( , curResult )
    end /* else */
  end /* if */

  if thisRC = 0 then
  do
    curResult = GetLengthOfTrack( curTrack )
    if curResult = '' then
    do
      call ShowMCIErrorDesc global.__mmpmError
      thisRC = -1
    end /* if */
    else
    do
      trackTime = MMTimeToSeconds( curResult )

      call DisplayResultMessage 'The length of the current track is ' || ,
                                AddColor1( , trackTime )
    end /* else */
  end /* if */

  if thisRC = 0 then
  do
    curResult = GetPositionOfTrack( curTrack )
    if curResult = '' then
    do
      call ShowMCIErrorDesc global.__mmpmError
      thisRC = -1
    end /* if */
    else
      call DisplayResultMessage 'The position of the current track is ' || ,
                                AddColor1( , curResult )
  end /* if */
return

/* ------------------------------------------------------------------ */
/*-function: Convert a MMTIME value into minutes:seconds              */
/*                                                                    */
/*-call:     MMTimeToSeconds trackLength                              */
/*                                                                    */
/*-where:    tracklength - track length in MMTME                      */
/*                                                                    */
/*-returns:  mm:ss                                                    */
/*                                                                    */
/*-Note:     -                                                        */
/*                                                                    */
MMTimeToSeconds: PROCEDURE expose (exposeList)
  parse arg trackLength
  thisRC = ''

  parse value ( trackLength / 3000 ) with seconds '.'
  minutes = seconds %  60
  seconds = seconds // 60
return minutes || ':' || right( seconds,2, '0' )

/* ------------------------------------------------------------------ */
/*-function: Load the necessary DLL                                   */
/*                                                                    */
/*-call:     LoadMCIRxInit                                            */
/*                                                                    */
/*-where:    -                                                        */
/*                                                                    */
/*-returns:  0 if successfull                                         */
/*                                                                    */
/*-Note:     -                                                        */
/*                                                                    */
LoadMCIRxInit: PROCEDURE expose (exposeList)
  call rxFuncAdd 'mciRxInit', 'MCIAPI', 'mciRxInit'
  thisRC = mciRxInit()
return thisRC

/* ------------------------------------------------------------------ */
/*-function: Terminate a REXX command file that contains MCI string   */
/*           commands                                                 */
/*                                                                    */
/*-call:     ExitMCI                                                  */
/*                                                                    */
/*-where:    -                                                        */
/*                                                                    */
/*-returns:  0 if successfull                                         */
/*                                                                    */
/*-Note:     -                                                        */
/*                                                                    */
ExitMCI:  PROCEDURE expose (exposeList)
  thisRC = CloseCDDevice()
  thisRC = mciRxExit()
return thisRC

/* ------------------------------------------------------------------ */
/*-function: Open the cd device                                       */
/*                                                                    */
/*-call:     OpenCDDevice                                             */
/*                                                                    */
/*-where:    -                                                        */
/*                                                                    */
/*-returns:  0 if successfull                                         */
/*                                                                    */
/*-Note:     global.__mmpmDeviceID contains the device ID             */
/*                                                                    */
OpenCDDevice: PROCEDURE expose (exposeList)
  global.__mmpmerror = 0
  mmpmCmd = 'open 'global.__cddevice 'shareable wait'
  global.__mmpmDeviceID = mciRxSendString( mmpmCmd, 'thisRC',0,0 )
return thisRC

/* ------------------------------------------------------------------ */
/*-function: Open the cd device                                       */
/*                                                                    */
/*-call:     CloseCDDevice                                            */
/*                                                                    */
/*-where:    -                                                        */
/*                                                                    */
/*                                                                    */
/*-returns:  0 if successfull                                         */
/*                                                                    */
/*-Note:     global.__mmpmerror contains 0 or the error number        */
/*                                                                    */
CloseCDDevice: PROCEDURE expose (exposeList)
  mmpmCmd = 'close 'global.__cddevice' wait'
  global.__mmpmerror = mciRxSendString( mmpmCmd, 'thisRC',0,0 )
return thisRC

/* ------------------------------------------------------------------ */
/*-function: get the number of tracks on the current cd               */
/*                                                                    */
/*-call:     GetNumberOfTracks                                        */
/*                                                                    */
/*-where:    -                                                        */
/*                                                                    */
/*-returns:  the number of tracks or '' in case of an error           */
/*                                                                    */
/*-Note:     global.__mmpmerror contains 0 or the error number        */
/*                                                                    */
GetNumberOfTracks: PROCEDURE expose (exposeList)
  mmpmCmd = 'status 'global.__cddevice' number of tracks wait'
  global.__mmpmerror = mciRxSendString( mmpmCmd, 'thisRC',0,0 )
return thisRC

/* ------------------------------------------------------------------ */
/*-function: get the number of the current track                      */
/*                                                                    */
/*-call:     GetNumberOfTheCurrentTrack                               */
/*                                                                    */
/*-where:    -                                                        */
/*                                                                    */
/*-returns:  the number of the current track or '' in case of an      */
/*           error                                                    */
/*                                                                    */
/*-Note:     global.__mmpmerror contains 0 or the error number        */
/*                                                                    */
GetNumberOfTheCurrentTrack: PROCEDURE expose (exposeList)
  mmpmCmd = 'status 'global.__cddevice' current track wait'
  global.__mmpmerror = mciRxSendString( mmpmCmd, 'thisRC',0,0 )
return thisRC

/* ------------------------------------------------------------------ */
/*-function: get the position of the current track                    */
/*                                                                    */
/*-call:     GetPositionInTheCurrentTrack                             */
/*                                                                    */
/*-where:    -                                                        */
/*                                                                    */
/*-returns:  the position of the current track or '' in case of an    */
/*           error                                                    */
/*                                                                    */
/*-Note:     global.__mmpmerror contains 0 or the error number        */
/*                                                                    */
GetPositionInTheCurrentTrack: PROCEDURE expose (exposeList)
  mmpmCmd = 'status 'global.__cddevice' position in track wait'
  global.__mmpmerror = mciRxSendString( mmpmCmd, 'thisRC',0,0 )
return thisRC

/* ------------------------------------------------------------------ */
/*-function: get the position of the track no. #                      */
/*                                                                    */
/*-call:     GetPositionOfTrack trackNo                               */
/*                                                                    */
/*-where:    trackNo - no of the track                                */
/*                                                                    */
/*-returns:  the position of the track or '' in case of an            */
/*           error                                                    */
/*                                                                    */
/*-Note:     global.__mmpmerror contains 0 or the error number        */
/*                                                                    */
GetPositionOfTrack: PROCEDURE expose (exposeList)
  parse arg trackNo

  mmpmCmd = 'status 'global.__cddevice' position track 'trackNo' wait'
  global.__mmpmerror = mciRxSendString( mmpmCmd, 'thisRC',0,0 )
return thisRC

/* ------------------------------------------------------------------ */
/*-function: set the current volume in percentage                     */
/*                                                                    */
/*-call:     SetVolume newValue                                       */
/*                                                                    */
/*-where:    newValue - volume in percentage (0 .. 100)               */
/*                                                                    */
/*-returns:  -                                                        */
/*                                                                    */
/*-Note:     global.__mmpmerror contains 0 or the error number        */
/*                                                                    */
SetVolume: PROCEDURE expose (exposeList)
  parse arg newValue

  mmpmCmd = 'set 'global.__cddevice' audio volume' newValue
  global.__mmpmerror = mciRxSendString( mmpmCmd, 'thisRC',0,0 )
return thisRC

/* ------------------------------------------------------------------ */
/*-function: SetSoundOn                                               */
/*                                                                    */
/*-call:     SetSoundOn                                               */
/*                                                                    */
/*-where:    -                                                        */
/*                                                                    */
/*-returns:  -                                                        */
/*                                                                    */
/*-Note:     global.__mmpmerror contains 0 or the error number        */
/*                                                                    */
SetSoundOn: PROCEDURE expose (exposeList)
  mmpmCmd = 'set 'global.__cddevice' audio on'
  global.__mmpmerror = mciRxSendString( mmpmCmd, 'thisRC',0,0 )
return thisRC

/* ------------------------------------------------------------------ */
/*-function: SetSoundOff                                              */
/*                                                                    */
/*-call:     SetSoundOff                                              */
/*                                                                    */
/*-where:    -                                                        */
/*                                                                    */
/*-returns:  -                                                        */
/*                                                                    */
/*-Note:     global.__mmpmerror contains 0 or the error number        */
/*                                                                    */
SetSoundOff: PROCEDURE expose (exposeList)
  mmpmCmd = 'set 'global.__cddevice' audio off'
  global.__mmpmerror = mciRxSendString( mmpmCmd, 'thisRC',0,0 )
return thisRC

/* ------------------------------------------------------------------ */
/*-function: get the current volume in percentage                     */
/*                                                                    */
/*-call:     GetVolume                                                */
/*                                                                    */
/*-where:    -                                                        */
/*                                                                    */
/*-returns:  nn / mm - volume for right and left                      */
/*                                                                    */
/*-Note:     global.__mmpmerror contains 0 or the error number        */
/*                                                                    */
GetVolume: PROCEDURE expose (exposeList)
  mmpmCmd = 'status 'global.__cddevice' volume wait'
  global.__mmpmerror = mciRxSendString( mmpmCmd, 'thisRC',0,0 )
return thisRC

/* ------------------------------------------------------------------ */
/*-function: get the length the track no. #                           */
/*                                                                    */
/*-call:     GetLengthOfTrack trackNo                                 */
/*                                                                    */
/*-where:    trackNo - no of the track                                */
/*                                                                    */
/*-returns:  the length of the track or '' in case of an              */
/*           error                                                    */
/*                                                                    */
/*-Note:     global.__mmpmerror contains 0 or the error number        */
/*                                                                    */
GetLengthOfTrack: PROCEDURE expose (exposeList)
  parse arg trackNo

  mmpmCmd = 'status 'global.__cddevice' length track 'trackNo' wait'
  global.__mmpmerror = mciRxSendString( mmpmCmd, 'thisRC',0,0 )
return thisRC

/* ------------------------------------------------------------------ */
/*-function: get the status of the cd device                          */
/*                                                                    */
/*-call:     GetDeviceStatus                                          */
/*                                                                    */
/*-where:    -                                                        */
/*                                                                    */
/*-returns:  the status code or '' in case of an                      */
/*           error                                                    */
/*                                                                    */
/*-Note:     global.__mmpmerror contains 0 or the error number        */
/*           Possible status codes are:                               */
/*           not ready / stopped / playing / seeking / recording /    */
/*           paused / other                                           */
/*                                                                    */
GetDeviceStatus: PROCEDURE expose (exposeList)
  mmpmCmd = 'status 'global.__cddevice' mode wait'
  global.__mmpmerror = mciRxSendString( mmpmCmd, 'thisRC',0,0 )
return thisRC

/* ------------------------------------------------------------------ */
/*-function: get the product information for the cdrom drive          */
/*                                                                    */
/*-call:     GetCDRomDescription                                      */
/*                                                                    */
/*-where:    -                                                        */
/*                                                                    */
/*-returns:  the product information associated with the cdrom drive  */
/*                                                                    */
/*-Note:     global.__mmpmerror contains 0 or the error number        */
/*                                                                    */
GetCDRomDescription: PROCEDURE expose (exposeList)
  mmpmCmd = 'info 'global.__cddevice' product'
  global.__mmpmerror = mciRxSendString( mmpmCmd, 'thisRC',0,0 )
return thisRC

/* ------------------------------------------------------------------ */
/*-function: check if the device is ready                             */
/*                                                                    */
/*-call:     DeviceReady                                              */
/*                                                                    */
/*-where:    -                                                        */
/*                                                                    */
/*-returns:  'TRUE' or '' in case of an                               */
/*           error                                                    */
/*                                                                    */
/*-Note:     global.__mmpmerror contains 0 or the error number        */
/*                                                                    */
DeviceReady: PROCEDURE expose (exposeList)
  mmpmCmd = 'status 'global.__cddevice' ready wait'
  global.__mmpmerror = mciRxSendString( mmpmCmd, 'thisRC',0,0 )
return thisRC

/* ------------------------------------------------------------------ */
/*-function: get the current position on the device                   */
/*                                                                    */
/*-call:     GetCurrentPosition                                       */
/*                                                                    */
/*-where:    -                                                        */
/*                                                                    */
/*-returns:  the position or '' in case of an                         */
/*           error                                                    */
/*                                                                    */
/*-Note:     global.__mmpmerror contains 0 or the error number        */
/*                                                                    */
GetCurrentPosition: PROCEDURE expose (exposeList)
  mmpmCmd = 'status 'global.__cddevice' position wait'
  global.__mmpmerror = mciRxSendString( mmpmCmd, 'thisRC',0,0 )
return thisRC

/* ------------------------------------------------------------------ */
/*-function: get the current volume                                   */
/*                                                                    */
/*-call:     GetCurrentVolume                                         */
/*                                                                    */
/*-where:    -                                                        */
/*                                                                    */
/*-returns:  the volume in the format n / m whre n is the percentage  */
/*           for the left channel and m is the percentage for the     */
/*           right channel ('' in case of an error)                   */
/*                                                                    */
/*-Note:     global.__mmpmerror contains 0 or the error number        */
/*                                                                    */
GetVolume: PROCEDURE expose (exposeList)
  mmpmCmd = 'status 'global.__cddevice' volume wait'
  global.__mmpmerror = mciRxSendString( mmpmCmd, 'thisRC',0,0 )
return thisRC

/* ------------------------------------------------------------------ */
/*-function: pause the device                                         */
/*                                                                    */
/*-call:     PauseDevice                                              */
/*                                                                    */
/*-where:    -                                                        */
/*                                                                    */
/*-returns:  nothing (check global.__mmpmerror for errors)            */
/*                                                                    */
/*-Note:     global.__mmpmerror contains 0 or the error number        */
/*                                                                    */
PauseDevice: PROCEDURE expose (exposeList)
  mmpmCmd = 'pause 'global.__cddevice''
  global.__mmpmerror = mciRxSendString( mmpmCmd, 'thisRC',0,0 )
return thisRC

/* ------------------------------------------------------------------ */
/*-function: resume the device                                        */
/*                                                                    */
/*-call:     ResumeDevice                                             */
/*                                                                    */
/*-where:    -                                                        */
/*                                                                    */
/*-returns:  nothing (check global.__mmpmerror for errors)            */
/*                                                                    */
/*-Note:     global.__mmpmerror contains 0 or the error number        */
/*                                                                    */
ResumeDevice: PROCEDURE expose (exposeList)
  mmpmCmd = 'resume 'global.__cddevice''
  global.__mmpmerror = mciRxSendString( mmpmCmd, 'thisRC',0,0 )
return thisRC

/* ------------------------------------------------------------------ */
/*-function: stop the cdrom                                           */
/*                                                                    */
/*-call:     stopDevice                                               */
/*                                                                    */
/*-where:    -                                                        */
/*                                                                    */
/*-returns:  nothing (check global.__mmpmerror for errors)            */
/*                                                                    */
/*-Note:     global.__mmpmerror contains 0 or the error number        */
/*                                                                    */
StopDevice: PROCEDURE expose (exposeList)
  mmpmCmd = 'stop 'global.__cddevice''
  global.__mmpmerror = mciRxSendString( mmpmCmd, 'thisRC',0,0 )
return thisRC

/* ------------------------------------------------------------------ */
/*-function: Seek to position n on the device                         */
/*                                                                    */
/*-call:     SeekToPosition newPosition                               */
/*                                                                    */
/*-where:    newPosition - new Position in mmtime (3000 per second)   */
/*                                                                    */
/*-returns:  nothing (check global.__mmpmerror for errors)            */
/*                                                                    */
/*-Note:     global.__mmpmerror contains 0 or the error number        */
/*                                                                    */
SeekToPosition: PROCEDURE expose (exposeList)
  parse arg newPosition
  mmpmCmd = 'seek 'global.__cddevice' to 'newPosition
  global.__mmpmerror = mciRxSendString( mmpmCmd, 'thisRC',0,0 )
return thisRC

/* ------------------------------------------------------------------ */
/*-function: Seek to start of the device                              */
/*                                                                    */
/*-call:     SeekToStart                                              */
/*                                                                    */
/*-where:    -                                                        */
/*                                                                    */
/*-returns:  nothing (check global.__mmpmerror for errors)            */
/*                                                                    */
/*-Note:     global.__mmpmerror contains 0 or the error number        */
/*                                                                    */
SeekToStart: PROCEDURE expose (exposeList)
  mmpmCmd = 'seek 'global.__cddevice' to start'
  global.__mmpmerror = mciRxSendString( mmpmCmd, 'thisRC',0,0 )
return thisRC

/* ------------------------------------------------------------------ */
/*-function: Seek to end of the device                                */
/*                                                                    */
/*-call:     SeekToEnd                                                */
/*                                                                    */
/*-where:    -                                                        */
/*                                                                    */
/*-returns:  nothing (check global.__mmpmerror for errors)            */
/*                                                                    */
/*-Note:     global.__mmpmerror contains 0 or the error number        */
/*                                                                    */
SeekToEnd: PROCEDURE expose (exposeList)
  mmpmCmd = 'seek 'global.__cddevice' to end'
  global.__mmpmerror = mciRxSendString( mmpmCmd, 'thisRC',0,0 )
return thisRC

/* ------------------------------------------------------------------ */
/*-function: Eject the cd                                             */
/*                                                                    */
/*-call:     OpenCDDrive                                              */
/*                                                                    */
/*-where:    -                                                        */
/*                                                                    */
/*-returns:  nothing (check global.__mmpmerror for errors)            */
/*                                                                    */
/*-Note:     global.__mmpmerror contains 0 or the error number        */
/*                                                                    */
OpenCDDrive: PROCEDURE expose (exposeList)
  mmpmCmd = 'set 'global.__cddevice' door open'
  global.__mmpmerror = mciRxSendString( mmpmCmd, 'thisRC',0,0 )
return thisRC

/* ------------------------------------------------------------------ */
/*-function: Close the cd drive                                       */
/*                                                                    */
/*-call:     CloseCDDrive                                             */
/*                                                                    */
/*-where:    -                                                        */
/*                                                                    */
/*-returns:  nothing (check global.__mmpmerror for errors)            */
/*                                                                    */
/*-Note:     global.__mmpmerror contains 0 or the error number        */
/*                                                                    */
CloseCDDrive: PROCEDURE expose (exposeList)
  mmpmCmd = 'set 'global.__cddevice' door closed'
  global.__mmpmerror = mciRxSendString( mmpmCmd, 'thisRC',0,0 )
return thisRC

/* ------------------------------------------------------------------ */
/*-function: Lock the cd drive                                        */
/*                                                                    */
/*-call:     LockCDDrive                                              */
/*                                                                    */
/*-where:    -                                                        */
/*                                                                    */
/*-returns:  nothing (check global.__mmpmerror for errors)            */
/*                                                                    */
/*-Note:     global.__mmpmerror contains 0 or the error number        */
/*                                                                    */
LockCDDrive: PROCEDURE expose (exposeList)
  mmpmCmd = 'set 'global.__cddevice' door locked'
  global.__mmpmerror = mciRxSendString( mmpmCmd, 'thisRC',0,0 )
return thisRC

/* ------------------------------------------------------------------ */
/*-function: Unlock the cd drive                                      */
/*                                                                    */
/*-call:     UnlockCDDrive                                            */
/*                                                                    */
/*-where:    -                                                        */
/*                                                                    */
/*-returns:  nothing (check global.__mmpmerror for errors)            */
/*                                                                    */
/*-Note:     global.__mmpmerror contains 0 or the error number        */
/*                                                                    */
UnlockCDDrive: PROCEDURE expose (exposeList)
  mmpmCmd = 'set 'global.__cddevice' door unlocked'
  global.__mmpmerror = mciRxSendString( mmpmCmd, 'thisRC',0,0 )
return thisRC

/* ------------------------------------------------------------------ */
/*-function: Set time format to MMTIME (3000 units per second)        */
/*                                                                    */
/*-call:     SetMMTimeFormat                                          */
/*                                                                    */
/*-where:    -                                                        */
/*                                                                    */
/*-returns:  nothing (check global.__mmpmerror for errors)            */
/*                                                                    */
/*-Note:     global.__mmpmerror contains 0 or the error number        */
/*                                                                    */
SetMMTimeFormat: PROCEDURE expose (exposeList)
  mmpmCmd = 'set 'global.__cddevice' time format MMTIME'
  global.__mmpmerror = mciRxSendString( mmpmCmd, 'thisRC',0,0 )
return thisRC

/* ------------------------------------------------------------------ */
/*-function: Play from position n to position m                       */
/*                                                                    */
/*-call:     PlayDevice begin [,end|length]                           */
/*                                                                    */
/*-where:    begin - position to start playing                        */
/*           end - position to end playing                            */
/*           length - no. of MMTIME ticks to play (use a leading + to */
/*                    distinguish between end and length)             */
/*           wait - wait until the command has ended                  */
/*                  (def.: do not wait)                               */
/*                                                                    */
/*-returns:  nothing (check global.__mmpmerror for errors)            */
/*                                                                    */
/*-Note:     global.__mmpmerror contains 0 or the error number        */
/*                                                                    */
PlayDevice: PROCEDURE expose (exposeList)
  parse arg begin, end, wait

  mmpmCmd = 'play 'global.__cddevice
  if begin <> '' then
    mmpmCmd = mmpmCmd ' from' begin

  if end <> '' then
  do
    if left( end,1 ) = '+' then
      end = begin + end
    mmpmCmd = mmpmCmd ' to ' end    
  end /* if */

  if wait <> '' then
    mmpmCmd = mmpmCmd 'WAIT'
  global.__mmpmerror = mciRxSendString( mmpmCmd, '',0,0 )

  thisRC = global.__mmpmError
return thisRC

/* ------------------------------------------------------------------ */
/*-function: Play the first n seconds of every track on the cd        */
/*                                                                    */
/*-call:     TryCD {seconds}                                          */
/*                                                                    */
/*-where:    seconds - no. of seconds to play for each track          */
/*                                                                    */
/*-returns:  -                                                        */
/*                                                                    */
/*-Note:     global.__mmpmerror contains 0 or the error number        */
/*                                                                    */
TryCD: PROCEDURE expose (exposeList)
  parse arg seconds

  signal on halt name TryCDEnd

  sampleDuration = seconds * 3000

  thisRC = 0

  call DisplayStatusMessage 'Playing the first ' || seconds || ,
                           ' seconds of every track on the cd ...'
  
                    /* get the number of tracks on the cd             */
  if thisRC = 0 then
  do
                    /* get number of tracks on the cd                 */
    call DisplayStatusMessage 'Inquiring the number of tracks on the cd ...'
    noOfTracks = GetNumberOfTracks()
    thisRC = global.__mmpmError
  end /* if */

  call DisplayResultMessage 'There are ' || AddColor1( , noOfTracks ),
                            || ' tracks on the cd'

  if thisRC = 0 then
  do
    do i = 1 to noOfTracks
                    /* get the position of the start track            */
      call DisplayStatusMessage 'Inquiring the position of the track ' || i  ||,
                                ' ...'
      mmpmCmd = 'status 'global.__cddevice' position track 'i' wait'
      thisRC = mciRxSendString( mmpmCmd, 'startPosition',0,0 )
      if thisRC = 0 then
      do
        call DisplayStatusMessage 'Playing the start of the track ' || i ||,
                                  ' ...'
        endPosition = startPosition + sampleDuration
        thisRC = PlayDevice( startPosition, endPosition, 'wait' )
      end /* if */
    end /* do */
  end /* if */

  if thisRC > 0 then
  do
                    /* error executing an MCI command                 */
     call ShowMCIErrorDesc thisRC
  end /* if */

return thisRC

TryCDEnd:
  return 0

/* ------------------------------------------------------------------ */
/*-function: PlayTracks                                               */
/*                                                                    */
/*-call:     PlayTracks startTrack {, endTrack}                       */
/*                                                                    */
/*-where:    startTrack - first track to play                         */
/*           endTrack - last track to play (def.: startTrack)         */
/*                                                                    */
/*-returns:  -                                                        */
/*                                                                    */
/*-Note:     global.__mmpmerror contains 0 or the error number        */
/*                                                                    */
PlayTracks: PROCEDURE expose (exposeList)
  parse arg startTrack, endTrack

                    /* init the error indicator with 'no error'       */
                    /* = 0 -> no error                                */
                    /* < 0 -> internal error                          */
                    /* > 0 -> MCI error                               */
  thisRC = 0

                    /* default for endtrack is starttrack             */
  if endTrack = '' then
    endTrack = startTrack
  noOfTracks = 0

                    /* swap starttrack and endtrack if necessary      */
  if endTrack < startTrack then
    parse value startTrack endTrack with endTrack StartTrack

                    /* only numbers are valid parameters              */
  if datatype( startTrack ) <> 'NUM' | datatype( endTrack ) <> 'NUM' then
  do
    call DisplayErrorMessage  'Invalid track number(s) entered'
    thisRC = -1
  end /* if */

  if thisRC = 0 then
  do
                    /* get number of tracks on the cd                 */
    call DisplayStatusMessage  'Inquiring the number of tracks on the cd ...'
    noOfTracks = GetNumberOfTracks()
    thisRC = global.__mmpmError
  end /* if */

  if thisRC = 0 & ( startTrack > noOfTracks ) then
  do
                    /* invalid track number entered                   */
    call DisplayErrorMessage  'Tracknumber is out of range (max is ' || noOfTracks || ')'
    thisRC = -1
  end /* if */

  if endTrack > noOfTracks then
    endTrack = noOfTracks

  if thisRC = 0 then
  do
                    /* get the position of the start track            */
    call DisplayStatusMessage  'Inquiring the position of the start track ...'
    mmpmCmd = 'status 'global.__cddevice' position track 'startTrack' wait'
    thisRC = mciRxSendString( mmpmCmd, 'startPosition',0,0 )
  end /* if */

  if thisRC = 0 then
  do
                    /* get the position of the last track             */
    if endTrack = startTrack then
    do
                    /* play only one track -> start track = end track */
      endTrackPosition = startPosition
    end /* if */
    else
    do
      call DisplayStatusMessage  'Inquiring the position of the last track ...'
      mmpmCmd = 'status 'global.__cddevice' position track 'endTrack' wait'
      thisRC = mciRxSendString( mmpmCmd, 'endTrackPosition',0,0 )
    end /* else */
  end /* if */

  if thisRC = 0 then
  do
                    /* get the length of the last track               */
    call DisplayStatusMessage  'Inquiring the length of the last track ...'
    mmpmCmd = 'status 'global.__cddevice' length track 'endTrack' wait'
    thisRC = mciRxSendString( mmpmCmd, 'lastTrackLength',0,0 )
    if lastTrackLength <> "" then
    do
      endPosition = endTrackPosition + lastTrackLength
    end /* if */
  end /* if */

  if thisRC = 0 then
  do
                    /* play the track(s)                              */
    call DisplayStatusMessage  'Playing the track(s) ...'
    thisRC = PlayDevice( startPosition, endPosition )
  end /* if */

  if thisRC > 0 then
  do
                    /* error executing an MCI command                 */
     call ShowMCIErrorDesc thisRC
  end /* if */

return thisRC

/* ------------------------------------------------------------------ */
/*-function: Show the contents of a cd                                */
/*                                                                    */
/*-call:     DirCD                                                    */
/*                                                                    */
/*-where:    -                                                        */
/*                                                                    */
/*-returns:  -                                                        */
/*                                                                    */
/*-Note:     global.__mmpmerror contains 0 or the error number        */
/*                                                                    */
DirCD: PROCEDURE expose (exposeList)

  thisRC = 0

                    /* get the number of tracks on the cd             */
  if thisRC = 0 then
  do
                    /* get number of tracks on the cd                 */
    call DisplayStatusMessage 'Inquiring the number of tracks on the cd ...'
    noOfTracks = GetNumberOfTracks()
    thisRC = global.__mmpmError
    call ShowMCIErrorDesc thisRC
  end /* if */

  if thisRC = 0 then
    call DisplayResultMessage 'There are ' || AddColor1( , noOfTracks ),
                              || ' tracks on the cd'

  cd. = ''
  cd.0 = noOfTracks
  totalTimeinMM = 0

  if thisRC = 0 then
  do
    do i = 1 to noOfTracks
                    /* get the position of the track                  */
      call DisplayStatusMessage 'Inquiring the position of the track ' || i  ||,
                                ' ...'
      mmpmCmd = 'status 'global.__cddevice' position track 'i' wait'
      thisRC = mciRxSendString( mmpmCmd, 'startPosition',0,0 )
      call ShowMCIErrorDesc thisRC
      if thisRC = 0 then
      do
        cd.i.position = startPosition
      end /* if */

                    /* get the length of the track       k            */
      call DisplayStatusMessage 'Inquiring the length of the track ' || i  ||,
                                ' ...'
      mmpmCmd = 'status 'global.__cddevice' length track 'i' wait'
      thisRC = mciRxSendString( mmpmCmd, 'tracklength',0,0 )
      call ShowMCIErrorDesc thisRC
      if thisRC = 0 then
      do
        cd.i.length = tracklength
        totalTimeinMM = totalTimeinMM + tracklength
        cd.i.length1 = MMTimeToSeconds( trackLength )
      end /* if */
    end /* do */

    call log
    call DisplayStatusMessage '"Directorylisting" of the CD'
    call log
    call log 'Track #       Start in MMTIME     Length in MMTIME      Length in mm:ss'
    call log '-----------------------------------------------------------------------'

    do i = 1 to cd.0

      tLine = right( i, 4 ) || '         ' || ,
              right( cd.i.position, 12 ) || '       ' || ,
              right( cd.i.length, 12 ) || '      ' || ,
              right( cd.i.length1, 12 ) || ' '
      call log tline
    end /* do */

    call log
    call log 'Total: ' || AddColor1( , cd.0 ) || ' tracks on the cd ' || ,
             '(= ' || AddColor1( , MMTimeToSeconds( totalTimeInMM ) ) || ')'
  end /* if */

return thisRC

/* ------------------------------------------------------------------ */
/*-function: Show Online help                                         */
/*                                                                    */
/*-call:     ShowOnlineHelp                                           */
/*                                                                    */
/*-where:    -                                                        */
/*                                                                    */
/*-returns:  -                                                        */
/*                                                                    */
/*-Note:     -                                                        */
/*                                                                    */
ShowOnlineHelp: PROCEDURE expose (exposeList)
  call log
  call log 'Possible commands:'
  call log 'SA[mples]          - show usage samples'
  call log 'Q[iet]             - leave the program '
  call log 'E[rror] #          - show the description for MMOS/2 error no #'
  call log 'V[olume] {#}       - read or set the volume'
  call log 'T[ry] {#}          - play every track for # seconds (def.: 10 sec.)'
  call log 'P[lay] {# {#n|+} } - play track # to track #n (def.: play all tracks)'
  call log 'S[top]             - stop playing'
  call log 'PA[use]            - pause playing'
  call log 'R[esume]           - resume playing'
  call log 'SO[und] {on|off}   - turn sound on or off'
  call log 'EJ[ect]            - eject the cd'
  call log 'L[oad]             - load a cd'
  call log 'D[dir]             - show cd contents'
  call log 'RER[ead]           - reread the cd'
  call log 'DE[bug]            - enter interactive test mode'
  call log 'C[md] command      - execute an OS command'
  call log '! command          - execute an OS command'
  call log '# statement        - execute a REXX statement'
return

/* ------------------------------------------------------------------ */
/*-function: Show Usage samples                                       */
/*                                                                    */
/*-call:     ShowSamples                                              */
/*                                                                    */
/*-where:    -                                                        */
/*                                                                    */
/*-returns:  -                                                        */
/*                                                                    */
/*-Note:     -                                                        */
/*                                                                    */
ShowSamples: PROCEDURE expose (exposeList)
  call log
  call log 'Usage samples'
  call log
  call log 'Command                     Description '
  call log '-----------------------------------------------------------'
  call log 'PLAY                        play the whole cd              '
  call log 'P 4                         play the track 4               '
  call log 'PLA 3 6                     play the tracks 3,4,5, and 6   '
  call log 'P 2 +                       play track 2 and the rest      '
  call log 'VOL                         get the current volume setting '
  call log 'VOL 30                      set the volume to 30%          '
  call log 'TRY 20                      play 20 sec. of every track    '
  call log 'SOUND on                    turn the sound on              '
  call log 'SO off                      turn the sound off             '
  call log '!dir                        show the current directory     '
  call log '!cmd                        open a cmd shell               '
return

/* ------------------------------------------------------------------ */

/* ------------------------------------------------------------------ */
/*-function: convert a MCI error no into an error string              */
/*                                                                    */
/*-call:     GetMCIErrorString errorNo                                */
/*                                                                    */
/*-where:    errorNo - error number                                   */
/*                                                                    */
/*-returns:  the error string                                         */
/*                                                                    */
/*-Note:     -                                                        */
/*                                                                    */
GetMCIErrorString: PROCEDURE expose (exposeList)
  parse arg errorNo

  if datatype( errorNo ) = 'NUM'  then
    call mciRxGetErrorString errorNo, 'thisRC' 
  else
    thisRC = '' 
return thisRC

/* ------------------------------------------------------------------ */
/*-function: Show the description for an MCI error                    */
/*                                                                    */
/*-call:     ShowMCIErrorDesc errorNo                                 */
/*                                                                    */
/*-where:    errorNo - error number                                   */
/*                                                                    */
/*-returns:  -                                                        */
/*                                                                    */
/*-Note:     -                                                        */
/*                                                                    */
ShowMCIErrorDesc: PROCEDURE expose (exposeList)
  parse arg errorNo
 
  call DisplayResultMessage 'The result is "' || errorNo || '"'

  if datatype( errorNo ) = 'NUM' & errorNo <> 0  then
  do
    errorString = GetMCIErrorString( errorNo ) 
    if errorString = '' then
      call DisplayErrorMessage  'No description available'
    else
      call DisplayErrorMessage  errorString
  end /* if errorNo <> 0 then */
return

/* ------------------------------------------------------------------ */
/*-function: Display error message                                    */
/*                                                                    */
/*-call:     DisplayErorMessage msg                                   */
/*                                                                    */
/*-where:    msg - error message                                      */
/*                                                                    */
/*-returns:  -                                                        */
/*                                                                    */
/*-Note:     -                                                        */
/*                                                                    */
DisplayErrorMessage: PROCEDURE expose (exposeList)
  parse arg msg
  call log screen.__ErrorColor || ErrorPrefix || msg screen.__NormalColor
return

/* ------------------------------------------------------------------ */
/*-function: Display status message                                   */
/*                                                                    */
/*-call:     DisplayStatusmessage msg                                 */
/*                                                                    */
/*-where:    msg - status message                                     */
/*                                                                    */
/*-returns:  -                                                        */
/*                                                                    */
/*-Note:     -                                                        */
/*                                                                    */
DisplayStatusMessage: PROCEDURE expose (exposeList)
  parse arg msg
  call log screen.__SignOnColor || StatusPrefix || msg screen.__NormalColor
return

/* ------------------------------------------------------------------ */
/*-function: Display result message                                   */
/*                                                                    */
/*-call:     DisplayResultmessage msg                                 */
/*                                                                    */
/*-where:    msg - result message                                     */
/*                                                                    */
/*-returns:  -                                                        */
/*                                                                    */
/*-Note:     -                                                        */
/*                                                                    */
DisplayResultMessage: PROCEDURE expose (exposeList)
  parse arg msg
  call log screen.__NormalColor || ResultPrefix || msg || ,
           screen.__NormalColor
return

/* ------------------------------------------------------------------ */
/*-function: test MCI commands interactive                            */
/*                                                                    */
/*-call:     TestMCI                                                  */
/*                                                                    */
/*-where:    -                                                        */
/*                                                                    */
/*-returns:  -                                                        */
/*                                                                    */
/*-Note:     -                                                        */
/*                                                                    */
TestMCI: PROCEDURE expose (exposeList)
  trace off

  do forever

                    /* show some help messages                        */
    call log ' ' || screen.__DebugColor || ,
                    centre( ' Interactive test mode ' , 78, '*' ) || ,
                    screen.__NormalColor

    call log ' ' || screen.__DebugColor || ,
                    centre( ' Caution: Every command to read the status needs the WAIT parameter!' , 78, ' ' ) || ,
                    screen.__NormalColor

    call log ' ' || screen.__DebugColor || ,
                    centre( 'The name of the cdrom device is ' || global.__cddevice , 78, ' ' ) || ,
                    screen.__NormalColor

    call log ' ' || screen.__DebugColor || ,
                    centre( 'Use a leading "!" for OS commands', 78, ' ' ) || ,
                    screen.__NormalColor

    call log ' ' || screen.__DebugColor || ,
                    centre( 'Use a leading "#" for REXX commands', 78, ' ' ) || ,
                    screen.__NormalColor

    call log screen.__PromptColor || ,
              'Enter mci command ("" to exit test mode):' || ,
              screen.__NormalColor

    call CharOut , InputPrefix
    curCmd = cmdLine()

    temp = prog.__QuietMode
    prog.__QuietMode = 1
    call log inputPrefix || curCmd
    prog.__QuietMode = temp

    parse var curCmd firstChar +1 extCommand

    select

      when curCmd = '' then
      do
        leave
      end /* when */

      when firstChar = '#' then
      do
                    /* execute a REXX command                         */
        call InterpretCommand extCommand
      end /* when */

      when firstChar = '!' then
      do
                    /* execute an OS command                          */
        call ExecuteOSCommand extCommand
      end /* when */

      otherwise
      do
                    /* execute a MCI command                          */
        thisRC = mciRxSendString( curCmd, 'tresult',0,0 )
        call log 'The returncode is ' || AddColor1( '"',thisRC ) || ,
              ', the result is ' || AddColor1( '"', tresult ) || '.'
        if thisRC <> 0 then
        do
          call mciRxGetErrorString thisRC, 'errstr'
          call log screen.__ErrorColor || ,
                   thisRC '-' errStr || ,
                   screen.__NormalColor
        end /* if */
      end /* otherwise */
    end /* select */
  end /* do forever */
return

/* ------------------------------------------------------------------ */
/* function: execute an OS command                                    */
/*                                                                    */
/* call:     ExecuteOSCommand cmd                                     */
/*                                                                    */
/* where:    cmd - command to execute                                 */
/*                                                                    */
/* returns:  0 - execution okay                                       */
/*           else error executing the command                         */
/*                                                                    */
/*                                                                    */
/* note:     do not use the keyword PROCEDURE!                        */
/*                                                                    */
ExecuteOSCommand:
  parse arg IC.__CurLine

                        /* init return code with failure code         */
  IC.__ThisRC = 1

                        /* install a local error handler              */
  SIGNAL ON SYNTAX    NAME ExecuteOSCommand1
  SIGNAL OFF NOVALUE 
  SIGNAL OFF FAILURE
  SIGNAL OFF ERROR  
  SIGNAL OFF NOTREADY

  'cmd /c ' IC.__CurLine
  call DisplayStatusMessage 'The return code of the OS command is ' || rc

ExecuteOSCommand1:
  return

/* ------------------------------------------------------------------ */
/* function: interpret a command simulating "CALL ON SYNTAX"          */
/*                                                                    */
/* call:     interpretCommand cmd                                     */
/*                                                                    */
/* where:    cmd - command to interpret                               */
/*                                                                    */
/* returns:  0 - execution okay                                       */
/*           else error executing the command                         */
/*                                                                    */
/*                                                                    */
/* note:     do not use the keyword PROCEDURE!                        */
/*                                                                    */
InterpretCommand:
  parse arg IC.__CurLine

                        /* init return code with failure code         */
  IC.__ThisRC = 1

                        /* install a local error handler              */
  SIGNAL ON SYNTAX    NAME InterpretCommand1
  SIGNAL OFF NOVALUE 
  SIGNAL OFF FAILURE
  SIGNAL OFF ERROR  
  SIGNAL OFF NOTREADY

                        /* execute the line                           */
  interpret IC.__CurLine

                        /* set return code to OK                      */
                        /* this statement is not executed if an error */
                        /* occurs while executing the previous        */
                        /* interpret command                          */
  IC.__ThisRC = 0

InterpretCommand1:
  if IC.__ThisRC = 1 then
  do
    call DisplayErrorMessage 'Error executing the REXX statement'
    IC.__ThisRC = rc
  end /* if */
                        /* drop unnecessary local variables         */
  drop IC.__CurLine

RETURN IC.__ThisRC

 