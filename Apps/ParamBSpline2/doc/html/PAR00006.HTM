<!-- Generated by HomePage Publisher - Version 2.1 Level(B) -->
<!-- Most recent revision: October 10, 2000. -->
<!-- Created on Thu Oct  5 14:06:36 2000 -->

<Html>
<Head>
   <Meta Name="Generator" Content="HomePage Publisher">
   <Meta Name="Hpp" Content="V=2.1 L=B Ecp=1004 Dcp=850 Lid=1-663">
   <Title></Title>
</Head>

<Body BgColor="#c0c0c0" Text="#000000" Link="#0000c0" Vlink="#ae00ae" Alink="#ff007f">
<BaseFont Size=3>
<H3 Align=Left>
   <Strong>BSpline Controls</Strong>
</H3>
The effect of these variables is illustrated in the comments section, <A Target="TextContent" Href="PAR00016.HTM">BSpline Illustrations</A>.

<P Align=Left><Strong>Mode</Strong>

<P Align=Left>The bspline fitting algorithm generates equations which satisfy certain conditions. One condition is a statistic which must be minimized or reduced below a given value. ParamBSpline uses either of two different statistics. One uses a least squares error sense. The other uses a more complex
condition that is sensitive to both the &quot;smoothness&quot; of the fit and a least squares error term. This is refered to as a &quot;smoothing spline.&quot; A mode of -1 will force use of the least squares sense. A mode of 0 uses the smoothing spline.<Br Clear=Left>
<Nobr>
<Pre><Code>Mode    = 0

             /* -1  - weighted least squares spline (Knots must be specified).
             /*  0  - smoothing spline.
</Pre></Nobr></Code>

<P Align=Left><Strong>Smooth</Strong>

<P Align=Left>If the smoothing spline option is used the Smooth parameter will cause the characteristics of the fit to change. There are no hard and fast rules for this value. The author of the original bspline code, Dr. Paul Dierckx recommends starting with a &quot;large&quot; value. Small changes
in Smooth have little impact in most cases. Try changing Smooth by factors of 10, i.e. from 1000 to 100 to 10. If you do not give a value for Smooth the number of data points will be used.

<P Align=Left>An infinitely large value for Smooth results in a least squares, polynomial fit. A value of 0 for smooth results in an interpolating spline, i.e. the curve will go through all input data.

<P Align=Left>For a fuller discussion of the mathematics behind the Smooth parameter see page 50 of Dr. Dierckx's <A Target="TextContent" Href="PAR00021.HTM">book </A>.  The effect of varying Smooth and Degree are shown below.  In the illustration Smooth is termed &quot;S&quot;.

<P Align=Left> <Img Border=10 Resize Width=257 Height=365 Vspace=10 Align=Middle Src="BSplineComp.GIF">

<P Align=Left><Nobr>
<Pre><Code>Smooth  = 1.0

             /* Smoothing.  Smooth&gt;=0.  Start &quot;big&quot; and work your way down.  If
             /* blank Smooth will be set to the number of points.
             /* A value of 0 will create an interpolating spline, i.e. it will
             /* go through the input data points in all cases.
</Pre></Nobr></Code>

<P Align=Left><Strong>Knots</Strong>

<P Align=Left>In BSplines knots, also refred to as break points, divide the data set into pieces. Obviously, the more pieces the closer the software can fit the observed values. Or conversely the more the software will reproduce the noise. Depends on your view point and purpose. If the least squares
spline option is used you must specify the number of knots to be used. If a value of 0 is used the data are fitted with a single polynomial. If the smoothing spline option is used the Knots parameter is ignored because the software automatically determines the number and position of the knots. Knot
locations are in terms of the &quot;u&quot; parameter, for which see below<Br>
<Nobr>
<Pre><Code>Knots   = 7

             /* Number of internal knots to use.  This is used when Mode = -1.
             /* Knots will be evenly spaced between start and stop of data.
             /* Knots  &lt;= (Number of data points) - Degree - 1
</Pre></Nobr></Code>

<P Align=Left><Nobr><Strong>Degree</Strong></Nobr>

<P Align=Left><Nobr>A spline is a polynomial fitted to the data between knots. You can select the degree of the polynomial to use. Typically a cubic, i.e. Degree = 3, is used. In some special cases other degrees may be useful.<Br>

<Pre><Code>Degree  = 3

             /* degree of spline.  1= Degree &lt;=5.
             /* &quot;It is recommended to use cubic splines (Degree=3)
             /* The user is strongly dissuaded from choosing Degree even, together
             /* with a small s-value.&quot;

</Pre></Nobr></Code>

<P Align=Left><Strong>UParam</Strong>

<P Align=Left>The input points must be ordered with respect to some strictly increasing value. In an ordinary, run-of-the-mill X,Y graph this would be the X axis values. But in many data sets there is no simple, existing variable against which the data may be so ordered. For example see the illustration
on the first page of this document. ParamBSpline2 can handle both cases. Where an existing variable does satisfy the requirement of monotonicity it may be used. For example if you have a data table of &quot;Depth&quot; versus &quot;Moisture&quot; you could set uParam to &quot;Depth&quot;. If you do
not have a satisfactory variable, when uParam is blank the program will compute a working variable, i.e. a parametric variable. The computed value is the runnning sum of the Euclidian distance in n-dimensions between adjacent points. The values are adjusted so that they go from 0 to 1.

<P Align=Left>This parametric variable is internally termed u. I have retained that terminology for lack of a better term.

<P Align=Left><Nobr>
<Pre><Code>uParam  = MyU

             /* The name of the variable to use as the &quot;u&quot; parameter.  If this
             /* means nothing to you perhaps you should read the documentation.
             /* As a hint, this is why this program is called Parametric BSpline.
             /* If no value is provided the scaled distance in n dimensions
             /* between subsequent points will be used with the total distance
             /* scaled to 1.
             /* A variable used as the uParam can not also be present in Use Variables
             /*
             /* WARNING - The numeric values of this variable MUST INCREASE
             /* each subsequent point.  In other words  u(i-1) &lt; u(i) &lt; u(i+1).
</Pre></Nobr></Code>

<P Align=Left><Strong>Weights</Strong>

<P Align=Left>If you know some points are more &quot;believable&quot; than others you may set a weight or significance for each point. The higher the value the more significant. This should be used with care if you aren't familiar with statistics and fitting algorithms.

<P Align=Left><Nobr>
<Pre><Code>Weights =

             /* The name of the variable to use as the weighting factor.
             /* If left blank a default weight of 1 is assigned to each point.
             /* Weights must be greater than 0.
</Pre></Nobr></Code>

<Hr Width="100%" Align=Center>

<Nobr>
<Pre><Code><A Target="TextContent" Href="PAR00007.HTM"><Strong>Forward</Strong></A>     <A Target="TextContent" Href="PAR00005.HTM"><Strong>Backward</Strong></A>     <A Target="TextContent" Href="PAR00001.HTM"><Strong>Return to Home Page</Strong></A>
</Pre></Nobr></Code>

<Hr Width="100%" Align=Center>

<P Align=Left>
</Body>
</Html>
